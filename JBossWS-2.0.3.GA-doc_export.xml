<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book>
<bookinfo><title>JBossWS 2.0.3.GA documentation</title><legalnotice><para>Permission to use, copy, modify and distribute this document under the GNU Free Documentation License (GFDL).</para></legalnotice></bookinfo><article id="User_Guide">
<title>User Guide</title>
<para>
Category:Development (User Guide)
</para>
<para>

</para>
<para>
This guide does cover <emphasis role="bold">JAX-WS</emphasis> functionality only, if you are looking for J2EE-1-4 compliant web services (i.e. the JSR-109 programming model) please goto the JAX-RPC_User_Guide.
</para>
<para>
To get started you need to <emphasis role="bold">download</emphasis> jbossws and <emphasis role="bold">install</emphasis> JBossWS on your preferred target container. Also consider running and looking at the source code of the JAX-WS samples available in every JBossWS binary distribution.
</para>
<para>
This user guide applies to <emphasis role="bold">jbossws-1.2.0</emphasis> and higher. For older versions, please consult the	<ulink url="http://labs.jboss.com/jbossws/user-guide/en/html/1.0.4/en/html/index.html"><citetitle>JBossWS User Guide</citetitle></ulink> on <ulink url="http://labs.jboss.com/portal/jbossws"><citetitle>JBoss.ORG</citetitle></ulink>.
</para>
<para>
Since 1.2
</para>
<section id="User_Guide_Web_Service_Concepts"><title>Web Service Concepts</title>
<section id="User_Guide_Document_2FLiteral"><title>Document/Literal</title>
<para>
With document style web services two business partners agree on the exchange of complex business documents that are well defined in XML schema. For example, one party sends a document describing a purchase order, the other responds (immediately or later) with a document that describes the status of the purchase order. No need to agree on such low level details as operation names and their associated parameters.
</para>
<para>
The payload of the SOAP message is an XML document that can be validated against XML schema.
</para>
<para>
Document is defined by the style attribute on the SOAP binding.
</para>
<para>
<programlisting>&lt;binding name='EndpointInterfaceBinding' type='tns:EndpointInterface'&gt;&lt;soap:binding style='document' transport='http://schemas.xmlsoap.org/soap/http'/&gt;&lt;operation name='concat'&gt;&lt;soap:operation soapAction=''/&gt;&lt;input&gt;&lt;soap:body use='literal'/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body use='literal'/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;/binding&gt;</programlisting>
</para>
<para>
With document style web services the payload of every message is defined by a complex type in XML schema.
</para>
<para>
<programlisting>&lt;complexType name='concatType'&gt;&lt;sequence&gt;&lt;element name='String_1' nillable='true' type='string'/&gt;&lt;element name='long_1' type='long'/&gt;&lt;/sequence&gt;&lt;/complexType&gt;&lt;element name='concat' type='tns:concatType'/&gt;</programlisting>
</para>
<para>
Therefore, message parts <emphasis role="bold">must</emphasis> refer to an <emphasis role="bold">element</emphasis> from the schema.
</para>
<para>
<programlisting>&lt;message name='EndpointInterface_concat'&gt;&lt;part name='parameters' element='tns:concat'/&gt;&lt;/message&gt;</programlisting>
</para>
<para>
The following message definition <emphasis role="bold">is invalid</emphasis>.
</para>
<para>
<programlisting>&lt;message name='EndpointInterface_concat'&gt;&lt;part name='parameters' type='tns:concatType'/&gt;&lt;/message&gt;</programlisting>
</para>
<section id="User_Guide_Document_2FLiteral__28Bare_29"><title>Document/Literal (Bare)</title>
<para>
Bare is an implementation detail from the Java domain. Neither in the abstract contract (i.e. wsdl+schema) nor at the SOAP message level is a bare endpoint recognizable.
</para>
<para>
A bare endpoint or client uses a Java bean that represents the entire document payload.
</para>
<para>
<programlisting>
@WebService
@SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE)
public class DocBareServiceImpl
{
 @WebMethod
 public SubmitBareResponse submitPO(SubmitBareRequest poRequest)
 {
 ...
 }
}
</programlisting>
</para>
<para>
The trick is that the Java beans representing the payload contain JAXB annotations that define how the payload is represented on the wire.
</para>
<para>
<programlisting>
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "SubmitBareRequest", namespace="http://soapbinding.samples.jaxws.ws.test.jboss.org/", propOrder = { "product" })
@XmlRootElement(namespace="http://soapbinding.samples.jaxws.ws.test.jboss.org/", name = "SubmitPO")
public class SubmitBareRequest
{
 @XmlElement(namespace="http://soapbinding.samples.jaxws.ws.test.jboss.org/", required = true)
 private String product;
 
 ...
}
</programlisting>
</para>

</section>
<section id="User_Guide_Document_2FLiteral__28Wrapped_29"><title>Document/Literal (Wrapped)</title>
<para>
Wrapped is an implementation detail from the Java domain. Neither in the abstract contract (i.e. wsdl+schema) nor at the SOAP message level is a wrapped endpoint recognizable.
</para>
<para>
A wrapped endpoint or client uses the individual document payload properties. Wrapped is the default and does not have to be declared explicitly.
</para>
<para>
<programlisting>
@WebService
public class DocWrappedServiceImpl
{
 @WebMethod
 @RequestWrapper (className="org.somepackage.SubmitPO")
 @ResponseWrapper (className="org.somepackage.SubmitPOResponse")
 public String submitPO(String product, int quantity)
 {
 ...
 }
}
</programlisting>
</para>
<para>
Note, that with JBossWS the request/response wrapper annotations are <emphasis role="bold">not required</emphasis>, they will be generated on demand using sensible defaults.
</para>

</section>

</section>
<section id="User_Guide_RPC_2FLiteral"><title>RPC/Literal</title>
<para>
With RPC there is a wrapper element that names the endpoint operation. Child elements of the RPC parent are the individual parameters. 
</para>
<para>
The SOAP body is constructed based on some simple rules:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
The port type operation name defines the endpoint method name
</para>
</listitem>
<listitem>
<para>
Message parts are endpoint method parameters
</para>
</listitem>
</itemizedlist>
<para>
RPC is defined by the style attribute on the SOAP binding.
</para>
<para>
<programlisting>&lt;binding name='EndpointInterfaceBinding' type='tns:EndpointInterface'&gt;&lt;soap:binding style='rpc' transport='http://schemas.xmlsoap.org/soap/http'/&gt;&lt;operation name='echo'&gt;&lt;soap:operation soapAction=''/&gt;&lt;input&gt;&lt;soap:body namespace='http://org.jboss.ws/samples/jsr181pojo' use='literal'/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body namespace='http://org.jboss.ws/samples/jsr181pojo' use='literal'/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;/binding&gt;</programlisting>
</para>
<para>
With rpc style web services the portType names the operation (i.e. the java method on the endpoint)
</para>
<para>
<programlisting>&lt;portType name='EndpointInterface'&gt;&lt;operation name='echo' parameterOrder='String_1'&gt;&lt;input message='tns:EndpointInterface_echo'/&gt;&lt;output message='tns:EndpointInterface_echoResponse'/&gt;&lt;/operation&gt;&lt;/portType&gt;</programlisting>
</para>
<para>
Operation parameters are defined by individual message parts.
</para>
<para>
<programlisting>&lt;message name='EndpointInterface_echo'&gt;&lt;part name='String_1' type='xsd:string'/&gt;&lt;/message&gt;&lt;message name='EndpointInterface_echoResponse'&gt;&lt;part name='result' type='xsd:string'/&gt;&lt;/message&gt;</programlisting>
</para>
<para>
Note, there is no complex type in XML schema that could validate the entire SOAP message payload.
</para>
<para>
<programlisting>
@WebService
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class JSEBean01
{
 @WebMethod
 @WebResult(name="result")
 public String echo(@WebParam(name="String_1") String input)
 {
 ...
 }
}
</programlisting>
</para>
<para>
The element names of RPC parameters/return values may be defined using the JAX-WS <link linkend="JAX_WS_Annotations_javax_jws_WebParam">WebParam</link> and <link linkend="JAX_WS_Annotations_javax_jws_WebResult">WebResult</link> annotations respectively.
</para>

</section>
<section id="User_Guide_RPC_2FEncoded"><title>RPC/Encoded</title>
<para>
SOAP encodeding style is defined by the infamous <ulink url="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383512"><citetitle>chapter 5</citetitle></ulink> of the <ulink url="http://www.w3.org/TR/2000/NOTE-SOAP-20000508"><citetitle>SOAP-1.1</citetitle></ulink> specification. <emphasis role="bold">It has inherent interoperability issues</emphasis> that cannot be fixed. The <ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html"><citetitle>Basic Profile-1.0</citetitle></ulink> prohibits this encoding style in <ulink url="http://www.ws-i.org/Profiles/BasicProfile-1.0-2004-04-16.html#refinement16448072"><citetitle>4.1.7 SOAP encodingStyle Attribute</citetitle></ulink>.
</para>
<para>
JBossWS has basic support for rpc/encoded that is <emphasis role="bold">provided as is</emphasis> for simple interop scenarios with SOAP stacks that do not support literal encoding.
</para>
<para>
Specifically, JBossWS does not support
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
element references
</para>
</listitem>
<listitem>
<para>
soap arrays as bean properties
</para>
</listitem>
</itemizedlist>

</section>

</section>
<section id="User_Guide_Web_Service_Endpoints"><title>Web Service Endpoints</title>
<para>
JAX-WS simplifies the development model for a web service endpoint a great deal. In short, an endpoint implementation bean is annotated with JAX-WS annotations and deployed to the server. The server automatically generates and publishes the abstract contract (i.e. wsdl+schema) for client consumption. All marshalling/unmarshalling is delegated to JAXB [2]. 
</para>
<section id="User_Guide_Plain_old_Java_Object__28POJO_29"><title>Plain old Java Object (POJO)</title>
<para>
Let's take a look at simple POJO endpoint implementation. All endpoint associated metadata is provided via JSR-181 annotations
</para>
<para>
<programlisting>
 @WebService
 @SOAPBinding(style = SOAPBinding.Style.RPC)
 public class JSEBean01
 {
 @WebMethod
 public String echo(String input)
 {
 ...
 }
 }
</programlisting>
</para>
<para>
<emphasis role="bold">The endpoint as a web application</emphasis>
</para>
<para>
A JAX-WS java service endpoint (JSE) is deployed as a web application.
</para>
<para>
<programlisting>&lt;web-app ...&gt;&lt;servlet&gt;&lt;servlet-name&gt;TestService&lt;/servlet-name&gt;&lt;servlet-class&gt;org.jboss.test.ws.jaxws.samples.jsr181pojo.JSEBean01&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;TestService&lt;/servlet-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</programlisting>
</para>
<para>
<emphasis role="bold">Packaging the endpoint</emphasis>
</para>
<para>
A JSR-181 java service endpoint (JSE) is packaged as a web application in a *.war file.
</para>
<para>
<programlisting>&lt;war warfile="${build.dir}/libs/jbossws-samples-jsr181pojo.war" webxml="${build.resources.dir}/samples/jsr181pojo/WEB-INF/web.xml"&gt;&lt;classes dir="${build.dir}/classes"&gt;&lt;include name="org/jboss/test/ws/samples/jsr181pojo/JSEBean01.class"/&gt;&lt;/classes&gt;&lt;/war&gt;</programlisting>
</para>
<para>
Note, only the endpoint implementation bean and web.xml are required.
</para>
<para>
<emphasis role="bold">Accessing the generated WSDL</emphasis>
</para>
<para>
A successfully deployed service endpoint will show up in the service endpoint manager. This is also where you find the links to the generated wsdl.
</para>
<para>
<programlisting>
 http://yourhost:8080/jbossws/services
</programlisting>
</para>
<para>
Note, it is also possible to generate the abstract contract off line using jbossw tools. For details of that please see <link linkend="JBossWS_JAX_WS_Tools_Bottom_Up__28Using_wsprovide_29">Bottom-Up (Java to WSDL)</link>
</para>

</section>
<section id="User_Guide_EJB3_Stateless_Session_Bean__28SLSB_29"><title>EJB3 Stateless Session Bean (SLSB)</title>
<para>
The JAX-WS programming model support the same set of annotations on EJB3 stateless session beans as on <link linkend="User_Guide_Plain_old_Java_Object__POJO_">Plain old Java Object (POJO)</link> endpoints. EJB-2.1 endpoints are supported using the JAX-RPC progamming model.
</para>
<para>
<programlisting>
 @Stateless
 @Remote(EJB3RemoteInterface.class)
 @RemoteBinding(jndiBinding = "/ejb3/EJB3EndpointInterface")

 @WebService
 @SOAPBinding(style = SOAPBinding.Style.RPC)
 public class EJB3Bean01 implements EJB3RemoteInterface
 {
 @WebMethod
 public String echo(String input)
 {
 ...
 }
 }
</programlisting>
</para>
<para>
Above you see an EJB-3.0 stateless session bean that exposes one method both on the remote interface and on and as an endpoint operation.
</para>
<para>
<emphasis role="bold">Packaging the endpoint</emphasis>
</para>
<para>
A JSR-181 EJB service endpoint is packaged as an ordinary ejb deployment.
</para>
<para>
<programlisting>&lt;jar jarfile="${build.dir}/libs/jbossws-samples-jsr181ejb.jar"&gt;&lt;fileset dir="${build.dir}/classes"&gt;&lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3Bean01.class"/&gt;&lt;include name="org/jboss/test/ws/samples/jsr181ejb/EJB3RemoteInterface.class"/&gt;&lt;/fileset&gt;&lt;/jar&gt;</programlisting>
</para>
<para>
<emphasis role="bold">Accessing the generated WSDL</emphasis>
</para>
<para>
A successfully deployed service endpoint will show up in the service endpoint manager. This is also where you find the links to the generated wsdl.
</para>
<para>
<programlisting>
 http://yourhost:8080/jbossws/services
</programlisting>
</para>
<para>
Note, it is also possible to generate the abstract contract off line using jbossw tools. For details of that please see <link linkend="JBossWS_JAX_WS_Tools_Bottom_Up__28Using_wsprovide_29">Bottom-Up (Java to WSDL)</link>
</para>

</section>
<section id="User_Guide_Endpoint_Provider"><title>Endpoint Provider</title>
<para>
JAX-WS services typically implement a native Java service endpoint interface (SEI), perhaps mapped froma WSDL port type, either directly or via the use of annotations. 
</para>
<para>
Java SEIs provide a high level Java-centric abstraction that hides the details of converting between Javaobjects and their XML representations for use in XML-based messages. However, in some cases it isdesirable for services to be able to operate at the XML message level. The Provider interface offers analternative to SEIs and may be implemented by services wishing to work at the XML message level.
</para>
<para>
A Provider based service instance?s invoke method is called for each message received for the service.
</para>
<para>
<programlisting>
 @WebServiceProvider(wsdlLocation = "WEB-INF/wsdl/Provider.wsdl")
 @ServiceMode(value = Service.Mode.PAYLOAD)
 public class ProviderBeanPayload implements Provider&lt;Source&gt;
 {
 public Source invoke(Source req)
 {
 // Access the entire request PAYLOAD and return the response PAYLOAD
 }
 }
</programlisting>
</para>
<para>
Note, Service.Mode.PAYLOAD is the default and does not have to be declared explicitly. You can also use Service.Mode.MESSAGE to access the entire SOAP message (i.e. with MESSAGE the Provider can also see SOAP Headers)
</para>
<para>
The abstract contract for a provider endpoint cannot be derived/generated automatically. Therefore it is necessary to specify the wsdlLocation with the @WebServiceProvider annotation.
</para>

</section>
<section id="User_Guide_WebServiceContext"><title>WebServiceContext</title>
<para>
The WebServiceContext is treated as an injectable resource that can be set at the time an endpoint isinitialized. The WebServiceContext object will then use thread-local information to return the correctinformation regardless of how many threads are concurrently being used to serve requests addressed to thesame endpoint object.
</para>
<para>
<programlisting>
 @WebService
 public class EndpointJSE
 {
 @Resource
 WebServiceContext wsCtx;
 
 @WebMethod
 public String testGetMessageContext()
 {
 SOAPMessageContext jaxwsContext = (SOAPMessageContext)wsCtx.getMessageContext();
 return jaxwsContext != null ? "pass" : "fail";
 }
 
 @WebMethod
 public String testGetUserPrincipal()
 {
 Principal principal = wsCtx.getUserPrincipal();
 return principal.getName();
 }
 
 @WebMethod
 public boolean testIsUserInRole(String role)
 {
 return wsCtx.isUserInRole(role);
 }
 }
</programlisting>
</para>

</section>
<section id="User_Guide_Secure_endpoints"><title>Secure endpoints</title>
<para>
Securing an endpoint requires you to <link linkend="Authentication">set the authentication configuration</link>.
</para>
<para>
Then you might want to secure the communication between service provider and consumer. This can be done at different levels:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<link linkend="Secure_transport">Secure the HTTP transport</link>
</para>
</listitem>
</itemizedlist>
<itemizedlist mark="opencircle"><listitem>
<para>
<link linkend="User_Guide_WS_Security">WS-Security</link>
</para>
</listitem>
</itemizedlist>

</section>

</section>
<section id="User_Guide_Web_Service_Clients"><title>Web Service Clients</title>
<section id="User_Guide_Service"><title>Service</title>
<para>
<literal>Service</literal> is an abstraction that represents a WSDL service. A WSDL service is a collection of related ports, each of which consists of a port type bound to a particular protocol and available at a particular endpoint address.
</para>
<para>
For most clients, you will start with a set of stubs generated from the WSDL. One of these will be the service, and you will create objects of that class in order to work with the service (see "static case" below).
</para>
<section id="User_Guide_Service_Usage"><title>Service Usage</title>
<para>
<emphasis role="bold">Static case</emphasis>
</para>
<para>
Most clients will start with a WSDL file, and generate some stubs using jbossws tools like <emphasis>wsconsume</emphasis>. This usually gives a mass of files, one of which is the top of the tree. This is the service implementation class.
</para>
<para>
The generated implementation class can be recognised as it will have two public constructors, one with no arguments and one with two arguments, representing the wsdl location (a java.net.URL) and the servicename (a javax.xml.namespace.QName) respectively.
</para>
<para>
Usually you will use the no-argument constructor. In this case the WSDL location and service name are those found in the WSDL. These are set implicitly from the WebServiceClient annotation that decorates the generated class.
</para>
<para>
The following code snippet shows the generated constructors from the generated class:
</para>
<para>
<programlisting>
 // Generated Service Class

 @WebServiceClient(name="StockQuoteService", targetNamespace="http://example.com/stocks", wsdlLocation="http://example.com/stocks.wsdl")
 public class StockQuoteService extends javax.xml.ws.Service 
 {
 public StockQuoteService() 
 {
 super(new URL("http://example.com/stocks.wsdl"), new QName("http://example.com/stocks", "StockQuoteService"));
 }

 public StockQuoteService(String wsdlLocation, QName serviceName) 
 {
 super(wsdlLocation, serviceName);
 }

 ...
}
</programlisting>
</para>
<para>
Section <link linkend="User_Guide_Dynamic_Proxy">Dynamic Proxy</link> explains how to obtain a port from the service and how to invoke an operation on the port. If you need to work with the XML payload directly or with the XML representation of the entire SOAP message, have a look at <link linkend="User_Guide_Dispatch">Dispatch</link>.
</para>
<para>
<emphasis role="bold">Dynamic case</emphasis>
</para>
<para>
In the dynamic case, when nothing is generated, a web service client uses <literal>Service.create</literal> to createService instances, the following code illustrates this process.
</para>
<para>
<programlisting>
 URL wsdlLocation = new URL("http://example.org/my.wsdl");
 QName serviceName = new QName("http://example.org/sample", "MyService");
 Service service = Service.create(wsdlLocation, serviceName);
</programlisting>
</para>
<para>
This is the nastiest way to work with JBossWs. Older versions have extensive details on DII as it was then known.
</para>

</section>
<section id="User_Guide_Handler_Resolver"><title>Handler Resolver</title>
<para>
JAX-WS provides a flexible plug-in framework for message processing modules, known as handlers, that may be used to extend the capabilities of a JAX-WS runtime system. <link linkend="User_Guide_Handler_Framework">Handler Framework</link> describes the handler framework in detail. A Service instance provides access to a HandlerResolver via a pair of getHandlerResolver/setHandlerResolver methods that may be used to configure a set of handlers on a per-service, per-port or per-protocol binding basis.
</para>
<para>
When a Service instance is used to create a proxy or a Dispatch instance then the handler resolver currently registered with the service is used to create the required handler chain. Subsequent changes to the handler resolver configured for a Service instance do not affect the handlers on previously created proxies, or Dispatch instances.
</para>
<para>
[TODO] <ulink url="http://jira.jboss.org/jira/browse/JBWS-1512"><citetitle>(JBWS-1512) Provide a sample for Service HandlerResolver</citetitle></ulink>
</para>

</section>
<section id="User_Guide_Executor"><title>Executor</title>
<para>
Service instances can be configured with a java.util.concurrent.Executor. The executor willthen be used to invoke any asynchronous callbacks requested by the application. The setExecutor andgetExecutor methods of Service can be used to modify and retrieve the executor configured for aservice.
</para>
<para>
[TODO] <ulink url="http://jira.jboss.org/jira/browse/JBWS-1513"><citetitle>(JBWS-1513) Provide a sample for Service Executor</citetitle></ulink>
</para>

</section>

</section>
<section id="User_Guide_Dynamic_Proxy"><title>Dynamic Proxy</title>
<para>
You can create an instance of a client proxy using one of getPort methods on the <link linkend="User_Guide_Service">Service</link>.
</para>
<para>
<programlisting>
 /** 
 * The getPort method returns a proxy. A service client
 * uses this proxy to invoke operations on the target
 * service endpoint. The &lt;code&gt;serviceEndpointInterface&lt;/code&gt;
 * specifies the service endpoint interface that is supported by
 * the created dynamic proxy instance.
 **/
 public &lt;T&gt; T getPort(QName portName, Class&lt;T&gt; serviceEndpointInterface)
 {
 ...
 }

 /** 
 * The getPort method returns a proxy. The parameter
 * &lt;code&gt;serviceEndpointInterface&lt;/code&gt; specifies the service
 * endpoint interface that is supported by the returned proxy.
 * In the implementation of this method, the JAX-WS
 * runtime system takes the responsibility of selecting a protocol
 * binding (and a port) and configuring the proxy accordingly.
 * The returned proxy should not be reconfigured by the client.
 *
 **/
 public &lt;T&gt; T getPort(Class&lt;T&gt; serviceEndpointInterface)
 {
 ...
 }
</programlisting>
</para>
<para>
The service endpoint interface (SEI) is usually generated using tools. For details see <link linkend="JBossWS_JAX_WS_Tools_Top_Down__28Using_wsconsume_29">Top Down (WSDL to Java)</link>
</para>
<para>
A generated static <link linkend="User_Guide_Service">Service</link> usually also offers typed methods to get ports. These methods also return dynamic proxies that implement the SEI.
</para>
<para>
<programlisting>
@WebServiceClient(name = "TestEndpointService", targetNamespace = "http://org.jboss.ws/wsref", 
 wsdlLocation = "http://localhost.localdomain:8080/jaxws-samples-webserviceref?wsdl")

public class TestEndpointService extends Service
{
 ...

 public TestEndpointService(URL wsdlLocation, QName serviceName) {
 super(wsdlLocation, serviceName);
 }

 @WebEndpoint(name = "TestEndpointPort")
 public TestEndpoint getTestEndpointPort() 
 {
 return (TestEndpoint)super.getPort(TESTENDPOINTPORT, TestEndpoint.class);
 }
}
</programlisting>
</para>

</section>
<section id="User_Guide_WebServiceRef"><title>WebServiceRef</title>
<para>
The WebServiceRef annotation is used to declare a reference to a Web service. It follows the resource pattern exemplified by the javax.annotation.Resource annotation in JSR-250 [5]
</para>
<para>
There are two uses to the WebServiceRef annotation:
</para>
<orderedlist numeration="arabic"><listitem>
<para>
To define a reference whose type is a generated service class. In this case, the type and value element will both refer to the generated service class type. Moreover, if the reference type can be inferred by the field/method declaration the annotation is applied to, the type and value elements MAY have the default value (Object.class, that is). If the type cannot be inferred, then at least the type element MUST be present with a non-default value.
</para>
</listitem>
<listitem>
<para>
To define a reference whose type is a SEI. In this case, the type element MAY be present with its default value if the type of the reference can be inferred from the annotated field/method declaration, but the value element MUST always be present and refer to a generated service class type (a subtype of javax.xml.ws.Service). The wsdlLocation element, if present, overrides theWSDL location information specified in the WebService annotation of the referenced generated service class.
</para>
</listitem>
</orderedlist>
<para>
<programlisting>
public class EJB3Client implements EJB3Remote
{
 @WebServiceRef
 public TestEndpointService service4;

 @WebServiceRef
 public TestEndpoint port3;
</programlisting>
</para>
<para>
<emphasis role="bold">WebServiceRef Customization</emphasis>
</para>
<para>
In jboss-5.0.x we offer a number of overrides and extensions to the WebServiceRef annotation. These include
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
define the port that should be used to resolve a container-managed port
</para>
</listitem>
<listitem>
<para>
define default Stub property settings for Stub objects
</para>
</listitem>
<listitem>
<para>
define the URL of a final WSDL document to be used
</para>
</listitem>
</itemizedlist>
<para>
Example:
</para>
<para>
<programlisting>&lt;service-ref&gt;&lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;&lt;wsdl-override&gt;file:/wsdlRepository/organization-service.wsdl&lt;/wsdl-override&gt;&lt;/service-ref&gt;&lt;service-ref&gt;&lt;service-ref-name&gt;OrganizationService&lt;/service-ref-name&gt;&lt;config-name&gt;Secure Client Config&lt;/config-name&gt;&lt;config-file&gt;META-INF/jbossws-client-config.xml&lt;/config-file&gt;&lt;handler-chain&gt;META-INF/jbossws-client-handlers.xml&lt;/handler-chain&gt;&lt;/service-ref&gt;&lt;service-ref&gt;&lt;service-ref-name&gt;SecureService&lt;/service-ref-name&gt;&lt;service-class-name&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpointService&lt;/service-class-name&gt;&lt;service-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointService&lt;/service-qname&gt;&lt;port-info&gt;&lt;service-endpoint-interface&gt;org.jboss.tests.ws.jaxws.webserviceref.SecureEndpoint&lt;/service-endpoint-interface&gt;&lt;port-qname&gt;{http://org.jboss.ws/wsref}SecureEndpointPort&lt;/port-qname&gt;&lt;stub-property&gt;&lt;name&gt;javax.xml.ws.security.auth.username&lt;/name&gt;&lt;value&gt;kermit&lt;/value&gt;&lt;/stub-property&gt;&lt;stub-property&gt;&lt;name&gt;javax.xml.ws.security.auth.password&lt;/name&gt;&lt;value&gt;thefrog&lt;/value&gt;&lt;/stub-property&gt;&lt;/port-info&gt;&lt;/service-ref&gt;</programlisting>
</para>
<para>
For details please see <emphasis role="bold">service-ref_5_0.dtd</emphasis> in the jboss docs directory.
</para>

</section>
<section id="User_Guide_Dispatch"><title>Dispatch</title>
<para>
XMLWeb Services use XML messages for communication between services and service clients. The higher level JAX-WS APIs are designed to hide the details of converting between Java method invocations and the corresponding XML messages, but in some cases operating at the XML message level is desirable. The Dispatch interface provides support for this mode of interaction.
</para>
<para>
Dispatch supports two usage modes, identified by the constants javax.xml.ws.Service.Mode.MESSAGE and javax.xml.ws.Service.Mode.PAYLOAD respectively:
</para>
<para>
<emphasis role="bold">Message</emphasis> In this mode, client applications work directly with protocol-specific message structures. E.g., when used with a SOAP protocol binding, a client application would work directly with a SOAP message.
</para>
<para>
<emphasis role="bold">Message Payload</emphasis> In this mode, client applications work with the payload of messages rather than the messages themselves. E.g., when used with a SOAP protocol binding, a client application would work with the contents of the SOAP Body rather than the SOAP message as a whole.
</para>
<para>
Dispatch is a low level API that requires clients to construct messages or message payloads as XML and requires an intimate knowledge of the desired message or payload structure. Dispatch is a generic class that supports input and output of messages or message payloads of any type.
</para>
<para>
<programlisting>
 Service service = Service.create(wsdlURL, serviceName);
 Dispatch dispatch = service.createDispatch(portName, StreamSource.class, Mode.PAYLOAD);

 String payload = "&lt;ns1:ping xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
 dispatch.invokeOneWay(new StreamSource(new StringReader(payload)));

 payload = "&lt;ns1:feedback xmlns:ns1='http://oneway.samples.jaxws.ws.test.jboss.org/'/&gt;";
 Source retObj = (Source)dispatch.invoke(new StreamSource(new StringReader(payload)));
</programlisting>
</para>

</section>
<section id="User_Guide_Asynchronous_Invocations"><title>Asynchronous Invocations</title>
<para>
The BindingProvider interface represents a component that provides a protocol binding for use by clients, it is implemented by proxies and is extended by the Dispatch interface.
</para>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="http://jbws.dyndns.org/mediawiki/images/3/3e/Binding-provider.gif"/>
</imageobject>
<textobject>
<phrase>Binding Provider Class Relationships</phrase>
</textobject>
</mediaobject>

</para>
<para>
BindingProvider instances may provide asynchronous operation capabilities. When used, asynchronous operation invocations are decoupled from the BindingProvider instance at invocation time such that the response context is not updated when the operation completes. Instead a separate response context is made available using the Response interface.
</para>
<para>
<programlisting>
 public void testInvokeAsync() throws Exception
 {
 URL wsdlURL = new URL("http://" + getServerHost() + ":8080/jaxws-samples-asynchronous?wsdl");
 QName serviceName = new QName(targetNS, "TestEndpointService");
 Service service = Service.create(wsdlURL, serviceName);
 TestEndpoint port = service.getPort(TestEndpoint.class);

 Response response = port.echoAsync("Async");

 // access future
 String retStr = (String) response.get();
 assertEquals("Async", retStr);
 }
</programlisting>
</para>

</section>
<section id="User_Guide_Oneway_Invocations"><title>Oneway Invocations</title>
<para>
@Oneway indicates that the given web method has only an input message and no output. Typically, a oneway method returns the thread of control to the calling application prior to executing the actual business method. 
</para>
<para>
<programlisting>
@WebService (name="PingEndpoint")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class PingEndpointImpl
{
 private static String feedback;
 
 @WebMethod
 @Oneway
 public void ping()
 {
 log.info("ping");
 feedback = "ok";
 }
 
 @WebMethod
 public String feedback()
 {
 log.info("feedback");
 return feedback;
 }
}
</programlisting>
</para>

</section>
<section id="User_Guide_JMS_Transport_Clients"><title>JMS Transport Clients</title>
<para>
Since 2.0.3
</para>
<para>
Since jbossws-2.0.3 we support JAX-WS clients that use JMS transport.
</para>
<para>
JMS transport is activated on the client side when the endpoint location uses the 'jms' URL schema
</para>
<para>
<programlisting>&lt;binding name='JMSBinding' type='tns:OrganizationJMSEndpoint'&gt;&lt;soap:binding style='rpc' transport='http://www.example.org/2006/06/soap/bindings/JMS/'/&gt;&lt;operation name='getContactInfo'&gt;&lt;soap:operation soapAction=''/&gt;&lt;input&gt;&lt;soap:body namespace='http://org.jboss.ws/samples/jmstransport' use='literal'/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body namespace='http://org.jboss.ws/samples/jmstransport' use='literal'/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;/binding&gt;&lt;service name='OrganizationJMSEndpointService'&gt;&lt;port binding='tns:JMSBinding' name='JMSEndpointPort'&gt;&lt;soap:address location='jms://queue/RequestQueue?replyToName=queue/ResponseQueue'/&gt;&lt;/port&gt;&lt;/service&gt;</programlisting>
</para>
<para>
The service that implements the JMS remote connection is loaded using the key
</para>
<para>
<programlisting>
 org.jboss.ws.core.client.RemoteConnection.jms
</programlisting>
</para>
<para>
Like any other service, this can be overwritten using a system property.
</para>
<para>
The JAX-WS client code is essentially no different from a client using HTTP as transport
</para>
<para>
<programlisting>
 public void testJMSEndpointPort() throws Exception
 {
 URL wsdlURL = new File("resources/jaxws/samples/jmstransport/jmsservice.wsdl").toURL();
 QName serviceName = new QName("http://org.jboss.ws/samples/jmstransport", "OrganizationJMSEndpointService");
 QName portName = new QName("http://org.jboss.ws/samples/jmstransport", "JMSEndpointPort");
 
 Service service = Service.create(wsdlURL, serviceName);
 Organization port = service.getPort(portName, Organization.class);
 
 String res = port.getContactInfo("mafia");
 assertEquals("The 'mafia' boss is currently out of office, please call again.", res);
 }
</programlisting>
</para>

</section>

</section>
<section id="User_Guide_Common_API"><title>Common API</title>
<para>
This sections describes concepts that apply equally to <link linkend="User_Guide_Web_Service_Endpoints">Web Service Endpoints</link> and <link linkend="User_Guide_Web_Service_Clients">Web Service Clients</link>
</para>
<section id="User_Guide_Handler_Framework"><title>Handler Framework</title>
<para>
The handler framework is implemented by a JAX-WS protocol binding in both client and server side runtimes. Proxies, and Dispatch instances, known collectively as binding providers, each use protocol bindings to bind their abstract functionality to specific protocols.
</para>
<para>
Client and server-side handlers are organized into an ordered list known as a handler chain. The handlers within a handler chain are invoked each time a message is sent or received. Inbound messages are processed by handlers prior to binding provider processing. Outbound messages are processed by handlers after any binding provider processing.
</para>
<para>
Handlers are invoked with a message context that provides methods to access and modify inbound and outbound messages and to manage a set of properties. Message context properties may be used to facilitate communication between individual handlers and between handlers and client and service implementations. Different types of handlers are invoked with different types of message context.
</para>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="http://jbws.dyndns.org/mediawiki/images/0/07/Binding-handler.gif"/>
</imageobject>
<textobject>
<phrase/>
</textobject>
</mediaobject>

</para>
<section id="User_Guide_Logical_Handler"><title>Logical Handler</title>
<para>
Handlers that only operate on message context properties and message payloads. Logical handlersare protocol agnostic and are unable to affect protocol specific parts of a message. Logical handlersare handlers that implement javax.xml.ws.handler.LogicalHandler.
</para>

</section>
<section id="User_Guide_Protocol_Handler"><title>Protocol Handler</title>
<para>
Handlers that operate on message context properties and protocol specific messages. Protocol handlers are specific to a particular protocol and may access and change protocol specific aspects of a message. Protocol handlers are handlers that implement any interface derived from javax.xml.ws.handler.Handler except javax.xml.ws.handler.LogicalHandler.
</para>

</section>
<section id="User_Guide_Service_endpoint_handlers"><title>Service endpoint handlers</title>
<para>
On the service endpoint, handlers are defined using the @HandlerChain annotation.
</para>
<para>
<programlisting>
@WebService
@HandlerChain(file = "jaxws-server-source-handlers.xml")
public class SOAPEndpointSourceImpl
{
 ...
}
</programlisting>
</para>
<para>
The location of the handler chain file supports 2 formats
</para>
<para>
1. An absolute java.net.URL in externalForm.(ex: http://myhandlers.foo.com/handlerfile1.xml)
</para>
<para>
2. A relative path from the source file or class file.(ex: bar/handlerfile1.xml)
</para>

</section>
<section id="User_Guide_Service_client_handlers"><title>Service client handlers</title>
<para>
On the client side, handler can be configured using the @HandlerChain annotation on the SEI or dynamically using the API.
</para>
<para>
<programlisting>
 Service service = Service.create(wsdlURL, serviceName);
 Endpoint port = (Endpoint)service.getPort(Endpoint.class);
 
 BindingProvider bindingProvider = (BindingProvider)port;
 List&lt;Handler&gt; handlerChain = new ArrayList&lt;Handler&gt;();
 handlerChain.add(new LogHandler());
 handlerChain.add(new AuthorizationHandler());
 handlerChain.add(new RoutingHandler());
 bindingProvider.getBinding().setHandlerChain(handlerChain); // important!
</programlisting>
</para>

</section>

</section>
<section id="User_Guide_Message_Context"><title>Message Context</title>
<para>
MessageContext is the super interface for all JAX-WS message contexts. It extends Map&lt;String,Object&gt; with additional methods and constants to manage a set of properties that enable handlers in a handler chain to share processing related state. For example, a handler may use the put method to insert a property in the message context that one or more other handlers in the handler chain may subsequently obtain via the get method.
</para>
<para>
Properties are scoped as either APPLICATION or HANDLER. All properties are available to all handlers for an instance of an MEP on a particular endpoint. E.g., if a logical handler puts a property in the message context, that property will also be available to any protocol handlers in the chain during the execution of an MEP instance. APPLICATION scoped properties are also made available to client applications (see section 4.2.1) and service endpoint implementations. The defaultscope for a property is HANDLER.
</para>
<section id="User_Guide_Accessing_the_message_context"><title>Accessing the message context</title>
<para>
There is currently no portable way of doing this in 4.0.5. <literal>@WebServiceContext</literal> injection will be available with 4.2. In the meantime you can access the message context like this: 
</para>
<para>
<programlisting>
CommonMessageContext msgContext = MessageContextAssociation.peekMessageContext(); 
msgContext.setProperty(&lt;Name&gt;, &lt;Value&gt;);
</programlisting>
</para>

</section>
<section id="User_Guide_Logical_Message_Context"><title>Logical Message Context</title>
<para>
<link linkend="User_Guide_Logical_Handler">Logical handlers</link> are passed a message context of type LogicalMessageContext when invoked. LogicalMessageContext extends MessageContext with methods to obtain and modify the message payload, it does not provide access to the protocol specific aspects of amessage. A protocol binding defines what component of a message are available via a logical message context. The SOAP binding defines that a logical handler deployed in a SOAP binding can access the contents of the SOAP body but not the SOAP headers whereas the XML/HTTP binding defines that a logical handler can access the entire XML payload of a message.
</para>

</section>
<section id="User_Guide_SOAP_Message_Context"><title>SOAP Message Context</title>
<para>
SOAP handlers are passed a SOAPMessageContext when invoked. SOAPMessageContext extends MessageContext with methods to obtain and modify the SOAP message payload.
</para>

</section>

</section>
<section id="User_Guide_Fault_Handling"><title>Fault Handling</title>
<para>
An implementation may thow a SOAPFaultException
</para>
<para>
<programlisting>
 public void throwSoapFaultException()
 {
 SOAPFactory factory = SOAPFactory.newInstance();
 SOAPFault fault = factory.createFault("this is a fault string!", new QName("http://foo", "FooCode"));
 fault.setFaultActor("mr.actor");
 fault.addDetail().addChildElement("test");
 throw new SOAPFaultException(fault);
 }
</programlisting>
</para>
<para>
or an application specific user exception
</para>
<para>
<programlisting>
 public void throwApplicationException() throws UserException
 {
 throw new UserException("validation", 123, "Some validation error");
 }
</programlisting>
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
In case of the latter JBossWS generates the required fault wrapper beans at runtime if they are not part of the deployment
</para>

</section>

</section>
<section id="User_Guide_DataBinding"><title>DataBinding</title>
<section id="User_Guide_Using_JAXB_with_non_annotated_classes"><title>Using JAXB with non annotated classes</title>
<para>
Since 2.0.2
</para>
<para>
JAXB is heavily driven by Java Annotations on the Java Bindings. It currently doesn't support an external binding configuration. This recently became an issue for us on JBossESB since the JBossWS 2.0.0 native SOAP stack uses JAXB to perform the SOAP to Java bindings (see 1, 2). It's an issue for JBossESB simply because it needs to be able to support user definition of JBossWS native Webservice Endpoints (e.g. JSR 181) using Java typesets that have not been "JAXB Annotated" (see JAXB Introductions On JBossWS).
</para>
<para>
In order to support this, we built on a JAXB RI feature whereby it allows you to specify a RuntimeInlineAnnotationReader implementation during JAXBContext creation (see JAXBRIContext).
</para>
<para>
We call this feature "JAXB Annotation Introduction" and we've made it available for general consumption i.e. it can be checked out, built and used from SVN:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
http://anonsvn.jboss.org/repos/jbossws/projects/jaxbintros/
</para>
</listitem>
</itemizedlist>
<para>
Complete documentation can be found here: 
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
http://wiki.jboss.org/wiki/Wiki.jsp?page=JAXBIntroductions
</para>
</listitem>
</itemizedlist>

</section>

</section>
<section id="User_Guide_Attachments"><title>Attachments</title>
<section id="User_Guide_MTOM_2FXOP"><title>MTOM/XOP</title>
<para>
This chapter describes Message Transmission Optimization Mechanism (MTOM) and XML-binary Optimized Packaging (XOP), a means of more efficiently serializing XML Infosets that have certain types of content. The related specifications are 
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="http://www.w3.org/TR/soap12-mtom/"><citetitle>SOAP Message Transmission Optimization Mechanism (MTOM)</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.w3.org/TR/xop10/"><citetitle>XML-binary Optimized Packaging (XOP)</citetitle></ulink>
</para>
</listitem>
</itemizedlist>
<section id="User_Guide_Supported_MTOM_parameter_types"><title>Supported MTOM parameter types</title>
<table>
<title/><tgroup cols="2"><tbody><row>
<entry>
image/jpeg
</entry>
<entry>
java.awt.Image
</entry>

</row>
<row>
<entry>
text/xml
</entry>
<entry>
javax.xml.transform.Source
</entry>

</row>
<row>
<entry>
application/xml
</entry>
<entry>
javax.xml.transform.Source
</entry>

</row>
<row>
<entry>
application/octet-stream
</entry>
<entry>
javax.activation.DataHandler
</entry>

</row>
</tbody></tgroup>
</table>
<para>
<programlisting/>
</para>
<para>
The above table shows a list of supported endpoint parameter types. The recommended approach is to use the <ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/activation/DataHandler.html"><citetitle>javax.activation.DataHandler</citetitle></ulink> classes to represent binary data as service endpoint parameters.
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
Microsoft endpoints tend to send any data as application/octet-stream. The only Java type that can easily cope with this ambiguity is javax.activation.DataHandler
</para>

</section>
<section id="User_Guide_Enabling_MTOM_per_endpoint"><title>Enabling MTOM per endpoint</title>
<para>
On the server side MTOM processing is enabled through the <literal>@BindingType</literal> annotation.JBossWS does handle SOAP1.1 and SOAP1.2. Both come with or without MTOM flavours:
</para>
<para>
<emphasis role="bold"> MTOM enabled service implementations </emphasis>
</para>
<para>
<programlisting>
package org.jboss.test.ws.jaxws.samples.xop.doclit;

import javax.ejb.Remote;
import javax.jws.WebService;
import javax.jws.soap.SOAPBinding;
import javax.xml.ws.BindingType;

@Remote
@WebService(targetNamespace = "http://org.jboss.ws/xop/doclit")
@SOAPBinding(style = SOAPBinding.Style.DOCUMENT, parameterStyle = SOAPBinding.ParameterStyle.BARE)
@BindingType(value="http://schemas.xmlsoap.org/wsdl/soap/http?mtom=true") (1)
public interface MTOMEndpoint {

 [...]
}
</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
The MTOM enabled SOAP 1.1 binding ID
</para>
</listitem>
</orderedlist>
<para>
<emphasis role="bold"> MTOM enabled clients </emphasis>
</para>
<para>
Web service clients can use the same approach described above or rely on the <literal>Binding</literal> API to enable MTOM(Excerpt taken from the <literal>org.jboss.test.ws.jaxws.samples.xop.doclit.XOPTestCase</literal>):
</para>
<para>
<programlisting>
[...]
Service service = Service.create(wsdlURL, serviceName);
port = service.getPort(MTOMEndpoint.class);

// enable MTOM
binding = (SOAPBinding)((BindingProvider)port).getBinding();
binding.setMTOMEnabled(true);

</programlisting>
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
You might as well use the JBossWS configuration templates to setup deployment defaults.
</para>

</section>

</section>
<section id="User_Guide_SwaRef"><title>SwaRef</title>
<para>
Since 2.0
</para>
<para>
<ulink url="http://www.ws-i.org/Profiles/AttachmentsProfile-1.0-2004-08-24.html"><citetitle>WS-I Attachment Profile 1.0</citetitle></ulink> defines mechanism to reference MIME attachment parts using <ulink url="http://www.ws-i.org/Profiles/AttachmentsProfile-1.0-2004-08-24.html#Referencing_Attachments_from_the_SOAP_Envelope"><citetitle>swaRef</citetitle></ulink>. In this mechanism the content of XML element of type wsi:swaRef is sent as MIME attachment and the element inside SOAP Body holds the reference to this attachment in the CID URI scheme as defined by RFC 2111.
</para>
<section id="User_Guide_Using_SwaRef_with_JAX_WS_endpoints"><title>Using SwaRef with JAX-WS endpoints</title>
<para>
JAX-WS endpoints delegate all marshalling/unmarshalling to the JAXB API. The most simple way to enable SwaRef encoding for <literal>DataHandler</literal> types is to annotate a payload bean with the <literal>@XmlAttachmentRef</literal> annotation as shown below:
</para>
<para>
<programlisting>
/**
* Payload bean that will use SwaRef encoding
*/
@XmlRootElement
public class DocumentPayload
{
 private DataHandler data;

 public DocumentPayload()
 {
 }

 public DocumentPayload(DataHandler data)
 {
 this.data = data;
 }
 
 @XmlElement
 @XmlAttachmentRef
 public DataHandler getData()
 {
 return data;
 }

 public void setData(DataHandler data)
 {
 this.data = data;
 }
}
</programlisting>
</para>
<para>
With document wrapped endpoints you may even specify the <literal>@XmlAttachmentRef</literal> annotation on the service endpoint interface:
</para>
<para>
<programlisting>
@WebService
public interface DocWrappedEndpoint
{
 @WebMethod
 DocumentPayload beanAnnotation(DocumentPayload dhw, String test);

 @WebMethod
 @XmlAttachmentRef
 DataHandler parameterAnnotation(@XmlAttachmentRef DataHandler data, String test);

}
</programlisting>
</para>
<para>
The message would then refer to the attachment part by CID:
</para>
<para>
<programlisting>&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;&lt;env:Header/&gt;&lt;env:Body&gt;&lt;ns2:parameterAnnotation xmlns:ns2='http://swaref.samples.jaxws.ws.test.jboss.org/'&gt;&lt;arg0&gt;cid:0-1180017772935-32455963@ws.jboss.org&lt;/arg0&gt;&lt;arg1&gt;Wrapped test&lt;/arg1&gt;&lt;/ns2:parameterAnnotation&gt;&lt;/env:Body&gt;&lt;/env:Envelope&gt;</programlisting>
</para>

</section>
<section id="User_Guide_Starting_from_WSDL"><title>Starting from WSDL</title>
<para>
If you chose the contract first approach then you need to ensure that any element declaration that should use SwaRef encoding simply refers to wsi:swaRef schema type:
</para>
<para>
<programlisting>&lt;element name="data" type="wsi:swaRef" 
xmlns:wsi="http://ws-i.org/profiles/basic/1.1/xsd"/&gt;</programlisting>
</para>
<para>
Any wsi:swaRef schema type would then be mapped to DataHandler.
</para>

</section>

</section>

</section>
<section id="User_Guide_Tools"><title>Tools</title>
<section id="User_Guide_JAX_WS_tools"><title>JAX-WS tools</title>
<para>
Please refer to <link linkend="JBossWS_JAX_WS_Tools">JBossWS_JAX-WS_Tools</link> for details. This covers directions on web service contract generation (bottom-up development) and consumption (top-down and client development).
</para>

</section>
<section id="User_Guide_Management_tools"><title>Management tools</title>
<para>
JBoss and its web service framework come with some tools allowing WS endpoint management.
</para>
<para>
Please refer the <link linkend="Endpoint_management">Endpoint management page</link> for an overview of the available tools. In particular the <link linkend="Records_management">Records management system</link> gives administrators a means of performing custom analysis of their web service traffic as well as exporting communication logs.
</para>

</section>

</section>
<section id="User_Guide_Web_Service_Extensions"><title>Web Service Extensions</title>
<section id="User_Guide_WS_Addressing"><title>WS-Addressing</title>
<para>
This section describes how <ulink url="http://www.w3.org/TR/ws-addr-core"><citetitle>WS-Addressing</citetitle></ulink> can be used to provide a stateful service endpoint.
</para>
<section id="User_Guide_Specifications"><title>Specifications</title>
<para>
WS-Addressing is defined by a combination of the following specifications from the W3C Candidate Recommendation 17 August 2005. The WS-Addressing API is standardized by <ulink url="http://www.jcp.org/en/jsr/detail?id=261"><citetitle>JSR-261 - Java API for XML Web Services Addressing</citetitle></ulink>
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="http://www.w3.org/TR/ws-addr-core"><citetitle>Web Services Addressing 1.0 - Core</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.w3.org/TR/ws-addr-soap"><citetitle>Web Services Addressing 1.0 - SOAP Binding</citetitle></ulink>
</para>
</listitem>
</itemizedlist>

</section>
<section id="User_Guide_Addressing_Endpoint"><title>Addressing Endpoint</title>
<para>
The following endpoint implementation has a set of operation for a typical stateful shopping chart application.
</para>
<para>
<programlisting>
 @WebService(name = "StatefulEndpoint", targetNamespace = "http://org.jboss.ws/samples/wsaddressing", serviceName = "TestService")
 @EndpointConfig(configName = "Standard WSAddressing Endpoint")
 @HandlerChain(file = "WEB-INF/jaxws-handlers.xml")
 @SOAPBinding(style = SOAPBinding.Style.RPC)
 public class StatefulEndpointImpl implements StatefulEndpoint, ServiceLifecycle
 {
 @WebMethod
 public void addItem(String item)
 { ... }
 
 @WebMethod
 public void checkout()
 { ... }
 
 @WebMethod
 public String getItems()
 { ... }
 }
</programlisting>
</para>
<para>
It uses the <link linkend="JAX_WS_Endpoint_Configuration_Standard_WSAddressing_Endpoint">Standard WSAddressing Endpoint</link> to enable the server side addressing handler. It processes the incomming WS-Addressing header elements and provides access to them through the JSR-261 API.
</para>
<para>
The endpoint handler chain
</para>
<para>
<programlisting>&lt;handler-chains xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee javaee_web_services_1_2.xsd"&gt;&lt;handler-chain&gt;&lt;protocol-bindings&gt;##SOAP11_HTTP&lt;/protocol-bindings&gt;&lt;handler&gt;&lt;handler-name&gt;Application Server Handler&lt;/handler-name&gt;&lt;handler-class&gt;org.jboss.test.ws.jaxws.samples.wsaddressing.ServerHandler&lt;/handler-class&gt;&lt;/handler&gt;&lt;/handler-chain&gt;&lt;/handler-chains&gt;</programlisting>
</para>
<para>
defines an application specific hander that assignes/processes stateful client ids.
</para>

</section>
<section id="User_Guide_Addressing_Client"><title>Addressing Client</title>
<para>
On the client side there are simmilar handlers that does the reverse. It uses the JSR-261 API to add WS-Addressing header elements including the clientid association.<programlisting> </programlisting>
</para>
<para>
The client sets a custom handler chain in the binding<programlisting> </programlisting>
</para>
<para>
<programlisting>
 Service service = Service.create(wsdlURL, serviceName);
 port1 = (StatefulEndpoint)service.getPort(StatefulEndpoint.class);
 BindingProvider bindingProvider = (BindingProvider)port1;

 List&lt;Handler&gt; customHandlerChain = new ArrayList&lt;Handler&gt;();
 customHandlerChain.add(new ClientHandler());
 customHandlerChain.add(new WSAddressingClientHandler());
 bindingProvider.getBinding().setHandlerChain(customHandlerChain);
</programlisting><programlisting> </programlisting>
</para>
<para>
The WSAddressingClientHandler is provided by JBossWS and reads/writes the addressing properties and puts then into the message context.
</para>
<para>
<emphasis role="bold">A client connecting to the stateful endpoint</emphasis>
</para>
<para>
<programlisting>
 public class AddressingStatefulTestCase extends JBossWSTest
 {
 public void testAddItem() throws Exception
 {
 port1.addItem("Ice Cream");
 port1.addItem("Ferrari");
 
 port2.addItem("Mars Bar");
 port2.addItem("Porsche");
 }
 
 public void testGetItems() throws Exception
 {
 String items1 = port1.getItems();
 assertEquals("[Ice Cream, Ferrari]", items1);
 
 String items2 = port2.getItems();
 assertEquals("[Mars Bar, Porsche]", items2);
 }
 }
</programlisting>
</para>
<para>
<emphasis role="bold">SOAP message exchange</emphasis>
</para>
<para>
Below you see the SOAP messages that are beeing exchanged. 
</para>
<para>
<programlisting>&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;&lt;wsa:To&gt;uri:jbossws-samples-wsaddr/TestService&lt;/wsa:To&gt;&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/action&lt;/wsa:Action&gt;&lt;wsa:ReferenceParameters&gt;&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;&lt;/wsa:ReferenceParameters&gt;&lt;/env:Header&gt;&lt;env:Body&gt;&lt;ns1:addItem xmlns:ns1='http://org.jboss.ws/samples/wsaddr'&gt;&lt;String_1&gt;Ice Cream&lt;/String_1&gt;&lt;/ns1:addItem&gt;&lt;/env:Body&gt;&lt;/env:Envelope&gt;&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;&lt;wsa:To&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/wsa:To&gt;&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/actionReply&lt;/wsa:Action&gt;&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;&lt;/env:Header&gt;&lt;env:Body&gt;&lt;ns1:addItemResponse xmlns:ns1='http://org.jboss.ws/samples/wsaddr'/&gt;&lt;/env:Body&gt;&lt;/env:Envelope&gt;
 
 ...
 
&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;&lt;wsa:To&gt;uri:jbossws-samples-wsaddr/TestService&lt;/wsa:To&gt;&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/action&lt;/wsa:Action&gt;&lt;wsa:ReferenceParameters&gt;&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;&lt;/wsa:ReferenceParameters&gt;&lt;/env:Header&gt;&lt;env:Body&gt;&lt;ns1:getItems xmlns:ns1='http://org.jboss.ws/samples/wsaddr'/&gt;&lt;/env:Body&gt;&lt;/env:Envelope&gt;&lt;env:Envelope xmlns:env='http://schemas.xmlsoap.org/soap/envelope/'&gt;&lt;env:Header xmlns:wsa='http://schemas.xmlsoap.org/ws/2004/08/addressing'&gt;&lt;wsa:To&gt;http://www.w3.org/2005/08/addressing/anonymous&lt;/wsa:To&gt;&lt;wsa:Action&gt;http://org.jboss.ws/addressing/stateful/actionReply&lt;/wsa:Action&gt;&lt;ns1:clientid xmlns:ns1='http://somens'&gt;clientid-1&lt;/ns1:clientid&gt;&lt;/env:Header&gt;&lt;env:Body&gt;&lt;ns1:getItemsResponse xmlns:ns1='http://org.jboss.ws/samples/wsaddr'&gt;&lt;result&gt;[Ice Cream, Ferrari]&lt;/result&gt;&lt;/ns1:getItemsResponse&gt;&lt;/env:Body&gt;&lt;/env:Envelope&gt;</programlisting>
</para>

</section>

</section>
<section id="User_Guide_WS_BPEL"><title>WS-BPEL</title>
<para>
WS-BPEL is not supported with JAX-WS, please refer to JAX-RPC User Guide#WS-BPEL.
</para>

</section>
<section id="User_Guide_WS_Eventing"><title>WS-Eventing</title>
<para>
WS-Eventing specifies a set of operations that allow an event consumer to register (subscribe) with an event producer (source) to receive events (notifications) in an asynchronous fashion. 
</para>
<section id="User_Guide_Specifications_2"><title>Specifications</title>
<para>
WS-Eventing is defined by the combination of the following specifications:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="ftp://www6.software.ibm.com/software/developer/library/ws-eventing/WS-Eventing.pdf"><citetitle>WS-Eventing specification</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.w3.org/TR/ws-addr-core"><citetitle>WS-Addressing Specifications</citetitle></ulink>
</para>
</listitem>
</itemizedlist>
<para>
The following section will introduce the main eventing actors and their responsiblities. 
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
The original eventing specification builds upon WS-Addressing 2004/08. JBossWS however decided to stick to the latest version, which is the W3C candidate release.
</para>

</section>
<section id="User_Guide_Collaboration"><title>Collaboration</title>
<para>
<mediaobject>
<imageobject>
<imagedata fileref="http://jbws.dyndns.org/mediawiki/images/8/8a/EventingCollaboration.gif"/>
</imageobject>
<textobject>
<phrase>Eventing collaboration</phrase>
</textobject>
</mediaobject>

</para>
<orderedlist numeration="arabic"><listitem>
<para>
An event sink (web service client) sends a subscribtion request to the event source endpoint. This includes the event sink endpoint address where notifications should delivered. Upon successful subscription the sink receives a leased subscription ID that can be used to identify the client in subsequent requests. 
</para>
</listitem>
<listitem>
<para>
A successfully registered event sink directs management requests (Renew, GetStatus, Unsubscribe) to the subscription manager endpoint using the previously received subscription ID. The subscription manager endpoint address was returned as part of the subscription response in the first place. 
</para>
</listitem>
<listitem>
<para>
The actual event sink (application) emits notification messages through the JBossWS-Eventing module. JBossWS-Eventing dispatches the notification to any subscriber endpoint that is registered with a particular event source.s 
</para>
</listitem>
<listitem>
<para>
Besides notifications JBossWS-Eventing may emit lifecycle events at any time, i.e. to inform an event sink that a subscription was canceled. This can be the case when the subscription expired or the event source was undeployed. 
</para>
</listitem>
</orderedlist>
<para>
It is the users responsibilty to supply the web service endpoints (EventSourceEndpoint, SubscriptionManagerEndpoint) that are required for a complete event source deployment. Fortunatly JBossWS-Eventing already ships with a implementation that can be used right away. All that's left todo is packaging of standard JSR-109 deployment archive that includes the event source specific WSDL and points to the JBossWS-Eventing endpoint implementations. 
</para>
<para>
The relevant steps are: 
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Create a custom WSDL that describes your event source, in respect to the notification schema (1) and the fact that is actually contains an event source port (2)
</para>
</listitem>
<listitem>
<para>
Use the JBossWS SEI (3) and endpoint (4) implementations (webservices.xml, web.xml).
</para>
</listitem>
</itemizedlist>

</section>
<section id="User_Guide_Setup_an_event_source_endpoint"><title>Setup an event source endpoint</title>
<para>
With JAX-WS the event source setup has actually become quiet easy. All you need to do is to subclass your endpoint implementation from <literal>AbstractEventSourceEndpoint</literal> and a subscription manager from <literal>AbstractSubscriptionManagerEndpoint</literal> and finally point that implementation to a <link linkend="User_Guide_The_WSDL_that_describes_an_event_source">event source specific WSDL</link>.
</para>
<para>
<programlisting>
package org.jboss.test.ws.jaxws.samples.wseventing;

import javax.jws.WebService;

import org.jboss.logging.Logger;
import org.jboss.ws.annotation.EndpointConfig;
import org.jboss.ws.extensions.eventing.jaxws.AbstractEventSourceEndpoint;

/**
 * @author Heiko.Braun@jboss.org
 * @version $Id$
 * @since 18.01.2007
 */
@WebService( (1)
 name = "EventSource",
 portName = "EventSourcePort",
 targetNamespace = "http://schemas.xmlsoap.org/ws/2004/08/eventing",
 wsdlLocation = "/WEB-INF/wsdl/sysmon.wsdl", (2)
 endpointInterface = "org.jboss.ws.extensions.eventing.jaxws.EventSourceEndpoint")
@EndpointConfig(configName = "Standard WSAddressing Endpoint") (3)
public class SysmonRegistrationEndpoint extends AbstractEventSourceEndpoint { (4)

 private static final Logger log = Logger.getLogger(SysmonRegistrationEndpoint.class);

 protected Logger getLogger()
 {
 return log;
 }
}

</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
Of course we need a <literal>@WebService</literal> annotation
</para>
</listitem>
<listitem>
<para>
It's important to override the WSDL here 
</para>
</listitem>
<listitem>
<para>
You need to tell JBossWS that it requires WS-Addressing for this endpoint
</para>
</listitem>
<listitem>
<para>
Subclass a predefined implementation that knows how to delegate to the actual eventing service implementation
</para>
</listitem>
</orderedlist>

</section>
<section id="User_Guide_The_WSDL_that_describes_an_event_source"><title>The WSDL that describes an event source</title>
<para>
Even though we are already using the annotation driven approach, JBossWS eventing still requires an event source specific WSDL. 
</para>
<para>
The following excerpt shows the relevant WSDL details that describe an event source. 
</para>
<para>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;wsdl:definitions
 targetNamespace="http://www.jboss.org/sysmon"
 xmlns:tns="http://www.jboss.org/sysmon"
 xmlns:wse='http://schemas.xmlsoap.org/ws/2004/08/eventing'
 xmlns:wsdl='http://schemas.xmlsoap.org/wsdl/'
 xmlns:wsa10='http://www.w3.org/2005/08/addressing'
 xmlns:xs='http://www.w3.org/2001/XMLSchema'
 xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"&gt;&lt;wsdl:import
(1) namespace='http://schemas.xmlsoap.org/ws/2004/08/eventing'
 location='jbwse.wsdl' /&gt;&lt;wsdl:types&gt;&lt;xs:schema targetNamespace='http://schemas.xmlsoap.org/ws/2004/08/eventing'&gt;
(2) &lt;xs:include schemaLocation='jbwse.xsd'/&gt;&lt;/xs:schema&gt;

(3) &lt;xs:schema
 targetNamespace="http://www.jboss.org/sysmon"
 elementFormDefault="qualified"
 blockDefault="#all"&gt;&lt;xs:element name="SystemStatus"&gt;&lt;xs:complexType&gt;&lt;xs:sequence&gt;&lt;xs:element name="Time " type="xs:dateTime"/&gt;&lt;xs:element name="HostName" type="xs:string"/&gt;&lt;xs:element name="HostAddress" type="xs:string"/&gt;&lt;xs:element name="ActiveThreadCount" type="xs:int"/&gt;&lt;xs:element name="FreeMemory" type="xs:string"/&gt;&lt;xs:element name="MaxMemory" type="xs:string"/&gt;&lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;/xs:element&gt;&lt;/xs:schema&gt;&lt;/wsdl:types&gt;&lt;wsdl:message name='SystemInfoMsg'&gt;&lt;wsdl:part name='body' element='tns:SystemStatus'/&gt;&lt;/wsdl:message&gt;

(4) &lt;wsdl:portType name='SystemInfo' wse:EventSource='true'&gt;&lt;wsdl:operation name='SysmonOp'&gt;&lt;wsdl:output message='tns:SystemInfoMsg'/&gt;&lt;/wsdl:operation&gt;&lt;/wsdl:portType&gt;&lt;wsdl:binding name="SystemInfoBinding" type="tns:SystemInfo"&gt;&lt;soap:binding style="document" transport="http://schemas.xmlsoap.org/soap/http"/&gt;&lt;wsdl:operation name="SysmonOp"&gt;&lt;soap:operation soapAction=""/&gt;&lt;wsdl:output&gt;&lt;soap:body use="literal"/&gt;&lt;/wsdl:output&gt;&lt;/wsdl:operation&gt;&lt;/wsdl:binding&gt;&lt;/wsdl:definitions&gt;</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
Import the default eventing WSDL, that includes service and port declarations.
</para>
</listitem>
<listitem>
<para>
Include the default eventing Types
</para>
</listitem>
<listitem>
<para>
Specifiy the notitification message schema.
</para>
</listitem>
<listitem>
<para>
Declare a port type, attributed "wse:EventSource='true'" that points to your notification message schema.
</para>
</listitem>
</orderedlist>

</section>
<section id="User_Guide_Emitting_notifications"><title>Emitting notifications</title>
<para>
JBossWS-Eventing registeres a event dispatcher within local JNDI tree that can be used to emit notifications from applications. <programlisting>
 java:/EventDispatcher
</programlisting>
</para>
<para>
The event dispatcher interface: <programlisting>
 public interface EventDispatcher
 {
 void dispatch(URI eventSourceNS, Element payload);
 }
</programlisting>
</para>
<para>
<emphasis role="bold"> Example notification </emphasis>
</para>
<para>
<programlisting>

(1) URI eventSourceURI = new URI("http://http://www.jboss.org/sysmon/SystemInfo");
(2) Element payload = DOMUtils.parse("SOME XML STRING");
 try
 {
 InitialContext iniCtx = getInitialContext();
(3) EventDispatcher delegate = (EventDispatcher)
 iniCtx.lookup(EventingConstants.DISPATCHER_JNDI_NAME);
(4) delegate.dispatch(eventSourceURI, payload);
 }
 catch (Exception e)
 {
 //
 }

</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
Address your event source correctly (TargetNamespace+PortTypeName)
</para>
</listitem>
<listitem>
<para>
Create your payload
</para>
</listitem>
<listitem>
<para>
Lookup dispatcher from JNDI
</para>
</listitem>
<listitem>
<para>
Dispatch notification.
</para>
</listitem>
</orderedlist>
<para>
The SubscriptionManager MBean is the actual core component that drives the JBossWS-Eventing implementation. It can be accessed through the jmx-console. <programlisting>
 jboss.ws.eventing:service=SubscriptionManager
</programlisting>
</para>
<para>
Management operations exist to monitor and maintain active subscritions and deployed event sources. The current implementation is backed by a ThreadPoolExecutor, that asynchronously delivers messages to event sink endpoints. It can be configured through the following attributes: 
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
corePoolSize - average number of idle threads
</para>
</listitem>
<listitem>
<para>
maximumPoolSize - maximum number of threads
</para>
</listitem>
<listitem>
<para>
eventKeepAlive - keep alive before an undelivered event message is discarded.
</para>
</listitem>
</itemizedlist>

</section>

</section>
<section id="User_Guide_WS_Security"><title>WS-Security</title>
<para>
WS-Security addresses message level security. It standardizes authorization, encryption, and digital signature processing of web services. Unlike transport security models, such as SSL, WS-Security applies security directly to the elements of the web service message. This increases the flexibility of your web services, by allowing any message model to be used (point to point, multi-hop relay, etc). 
</para>
<para>
This chapter describes how to use WS-Security to sign and encrypt a simple SOAP message.
</para>
<para>
<emphasis role="bold">Specifications</emphasis>
</para>
<para>
WS-Security is defined by the combination of the following specifications:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0.pdf"><citetitle>SOAP Message Security 1.0</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0.pdf"><citetitle>Username Token Profile 1.0</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0.pdf"><citetitle>X.509 Token Profile 1.0</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.w3.org/TR/xmlenc-core"><citetitle>W3C XML Encryption</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.w3.org/TR/xmldsig-core"><citetitle>W3C XML Signature</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.ws-i.org/Profiles/BasicSecurityProfile-1.0.html"><citetitle>Basic Security Profile 1.0 (Still in Draft)</citetitle></ulink>
</para>
</listitem>
</itemizedlist>
<section id="User_Guide_Endpoint_configuration"><title>Endpoint configuration</title>
<para>
JBossWS uses handlers to identify ws-security encoded requests and invoke the security components to sign and encrypt messages. In order to enable security processing, the client and server side need to include a corresponding handler configuration. The preferred way is to reference a predefined <link linkend="JAX_WS_Endpoint_Configuration">JAX-WS_Endpoint_Configuration</link> or <link linkend="JAX_WS_Client_Configuration">JAX-WS_Client_Configuration</link> respectively.
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
You need to setup both the endpoint configuration and the WSSE declarations.That's two separate steps.
</para>

</section>
<section id="User_Guide_Server_side_WSSE_declaration__28jboss_wsse_server_xml_29"><title>Server side WSSE declaration (jboss-wsse-server.xml)</title>
<para>
In this example we configure both the client and the server to sign the message body. Both also require this from each other. So, if you remove either the client or the server security deployment descriptor, you will notice that the other party will throw a fault explaining that the message did not conform to the proper security requirements.
</para>
<para>
<programlisting>&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config" 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.jboss.com/ws-security/config 
 http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
 (1) &lt;key-store-file&gt;WEB-INF/wsse.keystore&lt;/key-store-file&gt;
 (2) &lt;key-store-password&gt;jbossws&lt;/key-store-password&gt;
 (3) &lt;trust-store-file&gt;WEB-INF/wsse.truststore&lt;/trust-store-file&gt;
 (4) &lt;trust-store-password&gt;jbossws&lt;/trust-store-password&gt;
 (5) &lt;config&gt;
 (6) &lt;sign type="x509v3" alias="wsse"/&gt;
 (7) &lt;requires&gt;
 (8) &lt;signature/&gt;&lt;/requires&gt;&lt;/config&gt;&lt;/jboss-ws-security&gt;</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
This specifies that the key store we wish to use is WEB-INF/wsse.keystore, which is located in our war file.
</para>
</listitem>
<listitem>
<para>
This specifies that the store password is "jbossws". Password can be encypted using the {EXT} and {CLASS} commands. Please see samples for their usage.
</para>
</listitem>
<listitem>
<para>
This specifies that the trust store we wish to use is WEB-INF/wsse.truststore, which is located in our war file.
</para>
</listitem>
<listitem>
<para>
This specifies that the trust store password is also "jbossws". Password can be encrypted using the {EXT} and {CLASS} commands. Please see samples for their usage.
</para>
</listitem>
<listitem>
<para>
Here we start our root config block. The root config block is the default configuration for all services in this war file.
</para>
</listitem>
<listitem>
<para>
This means that the server must sign the message body of all responses. Type means that we are to use a X.509v3 certificate (a standard certificate). The alias option says that the certificate/key pair to use for signing is in the key store under the "wsse" alias
</para>
</listitem>
<listitem>
<para>
Here we start our optional requires block. This block specifies all security requirements that must be met when the server receives a message.
</para>
</listitem>
<listitem>
<para>
This means that all web services in this war file require the message body to be signed.
</para>
</listitem>
</orderedlist>
<para>
By default an endpoint does not use the WS-Security configuration. Use the proprietary @EndpointConfig annotation to set the config name. See <link linkend="JAX_WS_Endpoint_Configuration">JAX-WS_Endpoint_Configuration</link> for the list of available config names.
</para>
<para>
<programlisting>
@WebService
@EndpointConfig(configName = "Standard WSSecurity Endpoint")
public class HelloJavaBean
{
 ...
}
</programlisting>
</para>

</section>
<section id="User_Guide_Client_side_WSSE_declaration__28jboss_wsse_client_xml_29"><title>Client side WSSE declaration (jboss-wsse-client.xml)</title>
<para>
<programlisting>&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config" 
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.jboss.com/ws-security/config 
 http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
 (1) &lt;config&gt;
 (2) &lt;sign type="x509v3" alias="wsse"/&gt;
 (3) &lt;requires&gt;
 (4) &lt;signature/&gt;&lt;/requires&gt;&lt;/config&gt;&lt;/jboss-ws-security&gt;</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
Here we start our root config block. The root config block is the default configuration for all web service clients (Call, Proxy objects).
</para>
</listitem>
<listitem>
<para>
This means that the client must sign the message body of all requests it sends. Type means that we are to use a X.509v3 certificate (a standard certificate). The alias option says that the certificate/key pair to use for signing is in the key store under the "wsse" alias
</para>
</listitem>
<listitem>
<para>
Here we start our optional requires block. This block specifies all security requirements that must be met when the client receives a response.
</para>
</listitem>
<listitem>
<para>
This means that all web service clients must receive signed response messages.
</para>
</listitem>
</orderedlist>
<section id="User_Guide_Client_side_key_store_configuration"><title>Client side key store configuration</title>
<para>
We did not specify a key store or trust store, because client apps instead use the wsse System properties instead. If this was a web or ejb client (meaning a webservice client in a war or ejb jar file), then we would have specified them in the client descriptor.
</para>
<para>
Here is an excerpt from the JBossWS samples:
</para>
<para>
<programlisting>&lt;sysproperty key="org.jboss.ws.wsse.keyStore"
 value="${tests.output.dir}/resources/jaxrpc/samples/wssecurity/wsse.keystore"/&gt;&lt;sysproperty key="org.jboss.ws.wsse.trustStore" 
 value="${tests.output.dir}/resources/jaxrpc/samples/wssecurity/wsse.truststore"/&gt;&lt;sysproperty key="org.jboss.ws.wsse.keyStorePassword" value="jbossws"/&gt;&lt;sysproperty key="org.jboss.ws.wsse.trustStorePassword" value="jbossws"/&gt;&lt;sysproperty key="org.jboss.ws.wsse.keyStoreType" value="jks"/&gt;&lt;sysproperty key="org.jboss.ws.wsse.trustStoreType" value="jks"/&gt;</programlisting>
</para>
<para>
<emphasis role="bold">SOAP message exchange</emphasis>
</para>
<para>
Below you see the incomming SOAP message with the details of the security headers ommited. The idea is, that the SOAP body is still plain text, but it is signed in the security header and can therefore not manipulated in transit.
</para>
<para>
Incomming SOAPMessage<programlisting>&lt;env:Envelope xmlns:env="http://schemas.xmlsoap.org/soap/envelope/"&gt;&lt;env:Header&gt;&lt;wsse:Security env:mustUnderstand="1" ...&gt;&lt;wsu:Timestamp wsu:Id="timestamp"&gt;...&lt;/wsu:Timestamp&gt;&lt;wsse:BinarySecurityToken ...&gt;
 ...
 &lt;/wsse:BinarySecurityToken&gt;&lt;ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#"&gt;
 ...
 &lt;/ds:Signature&gt;&lt;/wsse:Security&gt;&lt;/env:Header&gt;&lt;env:Body wsu:Id="element-1-1140197309843-12388840" ...&gt;&lt;ns1:echoUserType xmlns:ns1="http://org.jboss.ws/samples/wssecurity"&gt;&lt;UserType_1 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;&lt;msg&gt;Kermit&lt;/msg&gt;&lt;/UserType_1&gt;&lt;/ns1:echoUserType&gt;&lt;/env:Body&gt;&lt;/env:Envelope&gt;</programlisting>
</para>

</section>

</section>
<section id="User_Guide_Installing_the_BouncyCastle_JCE_provider__28JDK_1_4_29"><title>Installing the BouncyCastle JCE provider (JDK 1.4)</title>
<para>
The information below has originaly been provided by <ulink url="http://www.bouncycastle.org/specifications.html#install"><citetitle>The Legion of the Bouncy Castle</citetitle></ulink>. 
</para>
<para>
The provider can be configured as part of your environment via static registration by adding an entry to the java.security properties file (found in $JAVA_HOME/jre/lib/security/java.security, where $JAVA_HOME is the location of your JDK/JRE distribution). You'll find detailed instructions in the file but basically it comes down to adding a line: 
</para>
<para>
<programlisting>
 security.provider.&lt;n&gt;=org.bouncycastle.jce.provider.BouncyCastleProvider
</programlisting>
</para>
<para>
Where &lt;n&gt; is the preference you want the provider at. 
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
Issues may arise if the Sun providers are not first.
</para>
<para>
Where you put the jar is mostly up to you, although with jdk1.4 the best (and in some cases only) place to have it is in $JAVA_HOME/jre/lib/ext. Under Windows there will normally be a JRE and a JDK install of Java if you think you have installed it correctly and it still doesn't work chances are you have added the provider to the installation not being used.
</para>

</section>
<section id="User_Guide_Keystore_2C_truststore___What_3F"><title>Keystore, truststore - What?</title>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
If you having a hard time understanding how the different trust- and keystore configurationsare used for signature and encryption, then read this thread first:http://www.jboss.org/index.html?module
</para>

</section>
<section id="User_Guide_Advanced_configuration"><title>Advanced configuration</title>
<para>
Further information and examples covering <link linkend="WS_Security_options">advanced WS-Security configuration options</link> are available. Those might help when specific settings are required to obtain interoperability with other vendors' WS-Security implementation.
</para>

</section>

</section>
<section id="User_Guide_WS_Transaction"><title>WS-Transaction</title>
<para>
Support for the WS-Coordination, WS-AtomicTransaction and WS-BusinessActivity specifications will be provided by technology recently acquired from Arjuna Technologies Ltd. This technology will be present within the JBoss Transactions 4.2.1 release. Further information can be obtained from the <ulink url="http://labs.jboss.org/portal/jbosstm"><citetitle>JBoss Transactions Project</citetitle></ulink>
</para>

</section>
<section id="User_Guide_XML_Registries"><title>XML Registries</title>
<para>
J2EE 1.4 mandates support for Java API for XML Registries (JAXR). Inclusion of a XML Registry with the J2EE 1.4 certified Application Server is optional. Starting jboss-4.0.2, JBoss ships a UDDI v2.0 compliant registry, the Apache jUDDI registry. We also provide support for JAXR Capability Level 0 (UDDI Registries) via integration of Apache Scout.
</para>
<para>
This chapter describes how to configure the jUDDI registry in JBoss and some sample code outlines for using JAXR API to publish and query the jUDDI registry.
</para>
<section id="User_Guide_Apache_jUDDI_Configuration"><title>Apache jUDDI Configuration</title>
<para>
Configuration of the jUDDI registry happens via an MBean Service that is deployed in the juddi-service.sar archive in the "all" configuration. The configuration of this service can be done in the jboss-service.xml of the META-INF directory in the juddi-service.sar
</para>
<para>
Let us look at the individual configuration items that can be changed.
</para>
<para>
DataSources configuration
</para>
<para>
<programlisting>&lt;attribute name="DataSourceUrl"&gt;java:/DefaultDS&lt;/attribute&gt;</programlisting>
</para>
<para>
Database Tables (Should they be created on start, Should they be dropped on stop, Should they be dropped on start etc)
</para>
<para>
<programlisting>&lt;attribute name="CreateOnStart"&gt;false&lt;/attribute&gt;&lt;attribute name="DropOnStop"&gt;true&lt;/attribute&gt;&lt;attribute name="DropOnStart"&gt;false&lt;/attribute&gt;</programlisting>
</para>
<para>
JAXR Connection Factory to be bound in JNDI. (Should it be bound? and under what name?)
</para>
<para>
<programlisting>&lt;attribute name="ShouldBindJaxr"&gt;true&lt;/attribute&gt;&lt;attribute name="BindJaxr"&gt;JAXR&lt;/attribute&gt;</programlisting>
</para>
<para>
Other common configuration:
</para>
<para>
Add authorized users to access the jUDDI registry. (Add a sql insert statement in a single line)
</para>
<para>
<programlisting>
 Look at the script META-INF/ddl/juddi_data.ddl for more details. Example for a user 'jboss'

 INSERT INTO PUBLISHER (PUBLISHER_ID,PUBLISHER_NAME,
 EMAIL_ADDRESS,IS_ENABLED,IS_ADMIN) 
 VALUES ('jboss','JBoss User','jboss@xxx','true','true');
</programlisting>
</para>

</section>
<section id="User_Guide_JBoss_JAXR_Configuration"><title>JBoss JAXR Configuration</title>
<para>
In this section, we will discuss the configuration needed to run the JAXR API. The JAXR configuration relies on System properties passed to the JVM. The System properties that are needed are:
</para>
<para>
<programlisting>
 javax.xml.registry.ConnectionFactoryClass=org.apache.ws.scout.registry.ConnectionFactoryImpl 
 jaxr.query.url=http://localhost:8080/juddi/inquiry 
 jaxr.publish.url=http://localhost:8080/juddi/publish
 juddi.proxy.transportClass=org.jboss.jaxr.juddi.transport.SaajTransport
</programlisting>
</para>
<para>
Please remember to change the hostname from "localhost" to the hostname of the UDDI service/JBoss Server.
</para>
<para>
You can pass the System Properties to the JVM in the following ways:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
When the client code is running inside JBoss (maybe a servlet or an EJB). Then you will need to pass the System properties in the run.sh/run.bat scripts to the java process via the "-D" option.
</para>
</listitem>
<listitem>
<para>
When the client code is running in an external JVM. Then you can pass the properties either as "-D" options to the java process or explicitly set them in the client code(not recommended).
</para>
</listitem>
</itemizedlist>
<para>
<programlisting>
 System.setProperty(propertyname, propertyvalue);
</programlisting>
</para>

</section>
<section id="User_Guide_JAXR_Sample_Code"><title>JAXR Sample Code</title>
<para>
There are two categories of API: JAXR Publish API and JAXR Inquiry API. The important JAXR interfaces that any JAXR client code will use are the following.
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/registry/RegistryService.html"><citetitle>javax.xml.registry.RegistryService</citetitle></ulink> From J2EE 1.4 JavaDoc: "This is the principal interface implemented by a JAXR provider. A registry client can get this interface from a Connection to a registry. It provides the methods that are used by the client to discover various capability specific interfaces implemented by the JAXR provider."
</para>
</listitem>
<listitem>
<para>
<ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/registry/BusinessLifeCycleManager.html"><citetitle>javax.xml.registry.BusinessLifeCycleManager</citetitle></ulink> From J2EE 1.4 JavaDoc: "The BusinessLifeCycleManager interface, which is exposed by the Registry Service, implements the life cycle management functionality of the Registry as part of a business level API. Note that there is no authentication information provided, because the Connection interface keeps that state and context on behalf of the client."
</para>
</listitem>
<listitem>
<para>
<ulink url="http://java.sun.com/j2ee/1.4/docs/api/javax/xml/registry/BusinessQueryManager.html"><citetitle>javax.xml.registry.BusinessQueryManager</citetitle></ulink> From J2EE 1.4 JavaDoc: "The BusinessQueryManager interface, which is exposed by the Registry Service, implements the business style query interface. It is also referred to as the focused query interface."
</para>
</listitem>
</itemizedlist>
<para>
Let us now look at some of the common programming tasks performed while using the JAXR API:
</para>
<para>
Getting a JAXR Connection to the registry.
</para>
<para>
<programlisting>
 String queryurl = System.getProperty("jaxr.query.url", "http://localhost:8080/juddi/inquiry");
 String puburl = System.getProperty("jaxr.publish.url", "http://localhost:8080/juddi/publish");

 Properties props = new Properties();
 props.setProperty("javax.xml.registry.queryManagerURL", queryurl);
 props.setProperty("javax.xml.registry.lifeCycleManagerURL", puburl);

 String transportClass = System.getProperty("juddi.proxy.transportClass", "org.jboss.jaxr.juddi.transport.SaajTransport");
 System.setProperty("juddi.proxy.transportClass", transportClass);

 // Create the connection, passing it the configuration properties
 factory = ConnectionFactory.newInstance();
 factory.setProperties(props);
 connection = factory.createConnection();
</programlisting>
</para>
<para>
Authentication with the registry.
</para>
<para>
<programlisting>
 /**
 * Does authentication with the uddi registry
 */
 protected void login() throws JAXRException
 {
 PasswordAuthentication passwdAuth = new PasswordAuthentication(userid, passwd.toCharArray());
 Set creds = new HashSet();
 creds.add(passwdAuth);

 connection.setCredentials(creds);
 }
</programlisting>
</para>
<para>
Save a Business
</para>
<para>
<programlisting>
 /**
 * Creates a Jaxr Organization with 1 or more services
 */
 protected Organization createOrganization(String orgname) throws JAXRException
 {
 Organization org = blm.createOrganization(getIString(orgname));
 org.setDescription(getIString("JBoss Inc"));
 Service service = blm.createService(getIString("JBOSS JAXR Service"));
 service.setDescription(getIString("Services of XML Registry"));
 //Create serviceBinding
 ServiceBinding serviceBinding = blm.createServiceBinding();
 serviceBinding.setDescription(blm.createInternationalString("Test Service Binding"));

 //Turn validation of URI off
 serviceBinding.setValidateURI(false);
 serviceBinding.setAccessURI("http://testjboss.org");

 // Add the serviceBinding to the service
 service.addServiceBinding(serviceBinding);

 User user = blm.createUser();
 org.setPrimaryContact(user);
 PersonName personName = blm.createPersonName("Anil S");
 TelephoneNumber telephoneNumber = blm.createTelephoneNumber();
 telephoneNumber.setNumber("111-111-7777");
 telephoneNumber.setType(null);
 PostalAddress address = blm.createPostalAddress("111", "My Drive", "BuckHead", "GA", "USA", "1111-111", "");
 Collection postalAddresses = new ArrayList();
 postalAddresses.add(address);
 Collection emailAddresses = new ArrayList();
 EmailAddress emailAddress = blm.createEmailAddress("anil@apache.org");
 emailAddresses.add(emailAddress);

 Collection numbers = new ArrayList();
 numbers.add(telephoneNumber);
 user.setPersonName(personName);
 user.setPostalAddresses(postalAddresses);
 user.setEmailAddresses(emailAddresses);
 user.setTelephoneNumbers(numbers);

 ClassificationScheme cScheme = getClassificationScheme("ntis-gov:naics", "");
 Key cKey = blm.createKey("uuid:C0B9FE13-324F-413D-5A5B-2004DB8E5CC2");
 cScheme.setKey(cKey);
 Classification classification = blm.createClassification(cScheme, "Computer Systems Design and Related Services", "5415");
 org.addClassification(classification);
 ClassificationScheme cScheme1 = getClassificationScheme("D-U-N-S", "");
 Key cKey1 = blm.createKey("uuid:3367C81E-FF1F-4D5A-B202-3EB13AD02423");
 cScheme1.setKey(cKey1);
 ExternalIdentifier ei = blm.createExternalIdentifier(cScheme1, "D-U-N-S number", "08-146-6849");
 org.addExternalIdentifier(ei);
 org.addService(service);
 return org;
 }
</programlisting>
</para>
<para>
Query a Business
</para>
<para>
<programlisting>
 /**
 * Locale aware Search a business in the registry
 */
 public void searchBusiness(String bizname) throws JAXRException
 {
 try
 {
 // Get registry service and business query manager
 this.getJAXREssentials();

 // Define find qualifiers and name patterns
 Collection findQualifiers = new ArrayList();
 findQualifiers.add(FindQualifier.SORT_BY_NAME_ASC);
 Collection namePatterns = new ArrayList();
 String pattern = "%" + bizname + "%";
 LocalizedString ls = blm.createLocalizedString(Locale.getDefault(), pattern);
 namePatterns.add(ls);

 // Find based upon qualifier type and values
 BulkResponse response = bqm.findOrganizations(findQualifiers, namePatterns, null, null, null, null);

 // check how many organisation we have matched
 Collection orgs = response.getCollection();
 if (orgs == null)
 {
 log.debug(" -- Matched 0 orgs");

 }
 else
 {
 log.debug(" -- Matched " + orgs.size() + " organizations -- ");

 // then step through them
 for (Iterator orgIter = orgs.iterator(); orgIter.hasNext();)
 {
 Organization org = (Organization)orgIter.next();
 log.debug("Org name: " + getName(org));
 log.debug("Org description: " + getDescription(org));
 log.debug("Org key id: " + getKey(org));
 checkUser(org);
 checkServices(org);
 }
 }
 }
 finally
 {
 connection.close();
 }
 }
</programlisting>
</para>
<para>
For more examples of code using the JAXR API, please refer to the resources in the Resources Section.
</para>

</section>
<section id="User_Guide_Trouble_Shooting"><title>Trouble Shooting</title>
<itemizedlist mark="opencircle"><listitem>
<para>
I cannot connect to the registry from JAXR. Please check the inquiry and publish url passed to the JAXR ConnectionFactory.
</para>
</listitem>
<listitem>
<para>
I cannot connect to the jUDDI registry. Please check the jUDDI configuration and see if there are any errors in the server.log. And also remember that the jUDDI registry is available only in the "all" configuration.
</para>
</listitem>
<listitem>
<para>
I cannot authenticate to the jUDDI registry. Have you added an authorized user to the jUDDI database, as described earlier in the chapter?
</para>
</listitem>
<listitem>
<para>
I would like to view the SOAP messages in transit between the client and the UDDI Registry. Please use the tcpmon tool to view the messages in transit. <ulink url="http://tcpmon.dev.java.net/"><citetitle>TCPMon</citetitle></ulink>
</para>
</listitem>
</itemizedlist>

</section>
<section id="User_Guide_Resources"><title>Resources</title>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="http://java.sun.com/webservices/jaxr/learning/tutorial/index.html"><citetitle>JAXR Tutorial and Code Camps</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://java.sun.com/j2ee/1.4/docs/tutorial/doc/"><citetitle>J2EE 1.4 Tutorial</citetitle></ulink>
</para>
</listitem>
<listitem>
<para>
<ulink url="http://www.amazon.com/exec/obidos/ASIN/0321146182"><citetitle>J2EE Web Services by Richard Monson-Haefel</citetitle></ulink>
</para>
</listitem>
</itemizedlist>

</section>

</section>
<section id="User_Guide_WS_Policy"><title>WS-Policy</title>
<para>
Since 2.1
</para>
<para>
The Web Services Policy Framework (WS-Policy) provides a general purpose model and corresponding syntax to describe the policies of a Web Service.
</para>
<para>
WS-Policy defines a base set of constructs that can be used and extended by other Web services specifications to describe a broad range of service requirements and capabilities.
</para>
<para>
Current JBoss implementation can instrument a webservice with policies attached at endpoint, port or port-type scope level only.There are two different methods to attach policies: providing a wsdl decorated with policies and policy attachments as defined by specifications, or using JBoss proprietary annotations. The first way has the advantage of being standard, while the second one is much more simple to implement. Of course the wsdl generated by these annotations conforms to standard defined in specifications and can be used with any ws-policy compliant client.
</para>
<para>
Please note that ws-policy specifications only define policy requirements and their attachment method to wsdl through specific extensions. It is out of the scope of ws-policy specifications and thus implementation to define and use the content of assertions. The way these assertions (called domain assertions or domain policies) have to be deployed and used is left to other specification like WS-Security-Policy or more generally to domain specific implementation.
</para>
<section id="User_Guide_Specification"><title>Specification</title>
<para>
WS-Policy is defined by the combination of the following specifications:<programlisting>   * <ulink url="http://www.w3.org/Submission/WS-Policy/"><citetitle>WS-Policy specification</citetitle></ulink></programlisting><programlisting>   * <ulink url="http://www.w3.org/Submission/WS-PolicyAttachment/"><citetitle>WS-Policy-Attachment specification</citetitle></ulink></programlisting>
</para>

</section>
<section id="User_Guide_Using_policies_in_a_user_provided_wsdl"><title>Using policies in a user provided wsdl</title>
<para>
To attach policies in this manner, the only thing you have to do in a webservice class is to provide a custom wsdl. This will cause JBossws to skip wsdl generation at deploy time, since the wsdl file you provided will be published. Please refer to specification (WS-Policy-Attachment) to learn how to modify wsdl to attach a policy.
</para>
<para>
Here you find an example of a webservice class and provided wsdl with a policy containing a domain assertion for JBoss wssecurity.
</para>
<para>
<programlisting>
@WebService(name = "Hello", 
targetNamespace = "http://org.jboss.ws/samples/wssecuritypolicy",
wsdlLocation="WEB-INF/wsdl/HelloService.wsdl")
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class HelloJavaBean
{
 private Logger log = Logger.getLogger(HelloJavaBean.class);

 @WebMethod
 public UserType echoUserType(@WebParam(name = "user") UserType in0)
 {
 log.info(in0);
 return in0;
 }
}
</programlisting>
</para>
<para>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;definitions name='HelloService' targetNamespace='http://org.jboss.ws/samples/wssecuritypolicy' xmlns='http://schemas.xmlsoap.org/wsdl/' xmlns:ns1='http://org.jboss.ws/samples/wssecurity' xmlns:soap='http://schemas.xmlsoap.org/wsdl/soap/' xmlns:tns='http://org.jboss.ws/samples/wssecuritypolicy' xmlns:wsp='http://schemas.xmlsoap.org/ws/2004/09/policy' xmlns:xsd='http://www.w3.org/2001/XMLSchema'&gt;&lt;types&gt;&lt;xs:schema targetNamespace='http://org.jboss.ws/samples/wssecurity' version='1.0' xmlns:xs='http://www.w3.org/2001/XMLSchema'&gt;&lt;xs:complexType name='UserType'&gt;&lt;xs:sequence&gt;&lt;xs:element minOccurs='0' name='msg' type='xs:string'/&gt;&lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;/xs:schema&gt;&lt;/types&gt;&lt;wsp:Policy wsu:Id='X509EndpointPolicy' xmlns:wsu='http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd'&gt;&lt;wsp:All&gt;&lt;sp:jboss-ws-security xmlns:sp='http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd'&gt;&lt;sp:key-store-file&gt;WEB-INF/wsse.keystore&lt;/sp:key-store-file&gt;&lt;sp:key-store-password&gt;jbossws&lt;/sp:key-store-password&gt;&lt;sp:trust-store-file&gt;WEB-INF/wsse.truststore&lt;/sp:trust-store-file&gt;&lt;sp:trust-store-password&gt;jbossws&lt;/sp:trust-store-password&gt;&lt;sp:config&gt;&lt;sp:encrypt alias='wsse' type='x509v3'/&gt;&lt;sp:requires&gt;&lt;sp:encryption/&gt;&lt;/sp:requires&gt;&lt;/sp:config&gt;&lt;/sp:jboss-ws-security&gt;&lt;/wsp:All&gt;&lt;/wsp:Policy&gt;&lt;message name='Hello_echoUserType'&gt;&lt;part name='user' type='ns1:UserType'/&gt;&lt;/message&gt;&lt;message name='Hello_echoUserTypeResponse'&gt;&lt;part name='return' type='ns1:UserType'/&gt;&lt;/message&gt;&lt;portType name='Hello'&gt;&lt;operation name='echoUserType' parameterOrder='user'&gt;&lt;input message='tns:Hello_echoUserType'/&gt;&lt;output message='tns:Hello_echoUserTypeResponse'/&gt;&lt;/operation&gt;&lt;/portType&gt;&lt;binding name='HelloBinding' type='tns:Hello'&gt;&lt;wsp:PolicyReference URI='#X509EndpointPolicy'/&gt;&lt;soap:binding style='rpc' transport='http://schemas.xmlsoap.org/soap/http'/&gt;&lt;operation name='echoUserType'&gt;&lt;soap:operation soapAction=''/&gt;&lt;input&gt;&lt;soap:body namespace='http://org.jboss.ws/samples/wssecuritypolicy' use='literal'/&gt;&lt;/input&gt;&lt;output&gt;&lt;soap:body namespace='http://org.jboss.ws/samples/wssecuritypolicy' use='literal'/&gt;&lt;/output&gt;&lt;/operation&gt;&lt;/binding&gt;&lt;service name='HelloService'&gt;&lt;port binding='tns:HelloBinding' name='HelloPort'&gt;&lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;&lt;/port&gt;&lt;/service&gt;&lt;/definitions&gt;</programlisting>
</para>
<para>
Please note in the wsdl file the wsp:Policy element and the wsp:PolicyReference in 'HelloBinding' binding Element.
</para>

</section>
<section id="User_Guide_Using_policies_with_JBoss_annotations"><title>Using policies with JBoss annotations</title>
<para>
Using JBoss proprietary annotation you only have to provide the policy xml, leaving wsdl generation to the JBossWS deployer.
</para>
<para>
There are two annotations to use, the first one (@PolicyAttachment) containing an array of the second one (@Policy): this lets you have many policies attached to a class or method.In future domain policy implementations might ship domain annotations extending the @Policy annotation to provide needed metadata directly as annotation parameters. The current @Policy annotation takes a reference to a xml file containing a generic policy description written respecting ws-policy specification rules. 
</para>
<para>
<programlisting>
/**

@Target(ElementType.TYPE) 
@Retention(RetentionPolicy.RUNTIME)
public @interface PolicyAttachment {
 Policy[] value();
}

</programlisting>
</para>
<para>
<programlisting>
@Retention(RetentionPolicy.RUNTIME)
public @interface Policy {
 
 public String policyFileLocation();
 
 public PolicyScopeLevel scope();
}
</programlisting>
</para>
<para>
And here you have the previous section example re-implemented using annotations and xml policy file:
</para>
<para>
<programlisting>
@WebService(name = "Hello", targetNamespace = "http://org.jboss.ws/samples/wssecurityAnnotatedpolicy")
@PolicyAttachment({@Policy( policyFileLocation="WEB-INF/Policy.xml", scope = PolicyScopeLevel.WSDL_PORT ) })
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class HelloJavaBean
{
 private Logger log = Logger.getLogger(HelloJavaBean.class);

 @WebMethod
 public UserType echoUserType(@WebParam(name = "user") UserType in0)
 {
 log.info(in0);
 return in0;
 }
}
</programlisting>
</para>
<para>
<programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;wsp:Policy wsu:Id="X509EndpointPolicy" xmlns:wsp="http://schemas.xmlsoap.org/ws/2004/09/policy" 
	 xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd"&gt;&lt;wsp:ExactlyOne&gt;&lt;wsp:All&gt;&lt;sp:jboss-ws-security xmlns:sp="http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;&lt;sp:key-store-file&gt;WEB-INF/wsse.keystore&lt;/sp:key-store-file&gt;&lt;sp:key-store-password&gt;jbossws&lt;/sp:key-store-password&gt;&lt;sp:trust-store-file&gt;WEB-INF/wsse.truststore&lt;/sp:trust-store-file&gt;&lt;sp:trust-store-password&gt;jbossws&lt;/sp:trust-store-password&gt;&lt;sp:config&gt;&lt;sp:encrypt type="x509v3" alias="wsse"/&gt;&lt;sp:requires&gt;&lt;sp:encryption/&gt;&lt;/sp:requires&gt;&lt;/sp:config&gt;&lt;/sp:jboss-ws-security&gt;&lt;/wsp:All&gt;&lt;/wsp:ExactlyOne&gt;&lt;/wsp:Policy&gt;</programlisting>
</para>

</section>

</section>

</section>
<section id="User_Guide_JBossWS_Extenstions"><title>JBossWS Extenstions</title>
<para>
This section describes propriatary JBoss extensions to JAX-WS.
</para>
<section id="User_Guide_Proprietary_Annotations"><title>Proprietary Annotations</title>
<para>
For the set of standard annotations, please have a look at <link linkend="JAX_WS_Annotations">JAX-WS_Annotations</link>
</para>
<section id="User_Guide_EndpointConfig"><title>EndpointConfig</title>
<para>
<programlisting>
/**
 * Defines an endpoint or client configuration. 
 * This annotation is valid on an endpoint implementaion bean or a SEI.
 * 
 * @author Heiko.Braun@jboss.org
 * @since 16.01.2007
 */
@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = { ElementType.TYPE })
public @interface EndpointConfig {

 /**
 * The optional config-name element gives the configuration name that must be present in
 * the configuration given by element config-file.
 *
 * Server side default: Standard Endpoint
 * Client side default: Standard Client
 */
 String configName() default "";

 /**
 * The optional config-file element is a URL or resource name for the configuration.
 *
 * Server side default: standard-jaxws-endpoint-config.xml
 * Client side default: standard-jaxws-client-config.xml
 */
 String configFile() default "";
}
</programlisting>
</para>

</section>
<section id="User_Guide_WebContext"><title>WebContext</title>
<para>
<programlisting>
/**
 * Provides web context specific meta data to EJB based web service endpoints.
 *
 * @author thomas.diesler@jboss.org
 * @since 26-Apr-2005
 */
@Retention(value = RetentionPolicy.RUNTIME)
@Target(value = { ElementType.TYPE })
public @interface WebContext {

 /** 
 * The contextRoot element specifies the context root that the web service endpoint is deployed to.
 * If it is not specified it will be derived from the deployment short name.
 * 
 * Applies to server side port components only. 
 */
 String contextRoot() default "";
 
 /** 
 * The virtual hosts that the web service endpoint is deployed to.
 * 
 * Applies to server side port components only.
 */
 String[] virtualHosts() default {};
 
 /** 
 * Relative path that is appended to the contextRoot to form fully qualified
 * endpoint address for the web service endpoint.
 * 
 * Applies to server side port components only. 
 */
 String urlPattern() default "";

 /**
 * The authMethod is used to configure the authentication mechanism for the web service. 
 * As a prerequisite to gaining access to any web service which are protected by an authorization
 * constraint, a user must have authenticated using the configured mechanism.
 *
 * Legal values for this element are "BASIC", or "CLIENT-CERT".
 */
 String authMethod() default "";

 /**
 * The transportGuarantee specifies that the communication
 * between client and server should be NONE, INTEGRAL, or
 * CONFIDENTIAL. NONE means that the application does not require any
 * transport guarantees. A value of INTEGRAL means that the application
 * requires that the data sent between the client and server be sent in
 * such a way that it can't be changed in transit. CONFIDENTIAL means
 * that the application requires that the data be transmitted in a
 * fashion that prevents other entities from observing the contents of
 * the transmission. In most cases, the presence of the INTEGRAL or
 * CONFIDENTIAL flag will indicate that the use of SSL is required.
 */
 String transportGuarantee() default "";

 /**
 * A secure endpoint does not by default publish it's wsdl on an unsecure transport.
 * You can override this behaviour by explicitly setting the secureWSDLAccess flag to false.
 * 
 * Protect access to WSDL. See http://jira.jboss.org/jira/browse/JBWS-723 
 */
 boolean secureWSDLAccess() default true;
}
</programlisting>
</para>

</section>
<section id="User_Guide_SecurityDomain"><title>SecurityDomain</title>
<para>
<programlisting>
/**
 * Annotation for specifying the JBoss security domain for an EJB
 * 
 * @author &lt;a href="mailto:bill@jboss.org"&gt;Bill Burke&lt;/a&gt;
 **/
@Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME)
public @interface SecurityDomain
{
 /**
 * The required name for the security domain.
 * 
 * Do not use the JNDI name
 * 
 * Good: "MyDomain"
 * Bad: "java:/jaas/MyDomain"
 */
 String value();
 
 /**
 * The name for the unauthenticated pricipal
 */
 String unauthenticatedPrincipal() default "";
}
</programlisting>
</para>
<para>
Since 2.0.3
</para>

</section>
<section id="User_Guide_Documentation"><title>Documentation</title>
<para>
<programlisting>
package org.jboss.ws.annotation;

/**
 * Annotation to be used to add wsdl:documentation elements to the generated wsdl.
 *
 * @author alessio.soldano@jboss.org
 * @since 15-Jan-2008
 */
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Documentation
{
 public String content();
}
</programlisting>
</para>

</section>

</section>
<section id="User_Guide_Deployment_descriptor_attributes"><title>Deployment descriptor attributes</title>
<section id="User_Guide_JSE_Endpoints"><title>JSE Endpoints</title>
<para>
The following is taken from http://anonsvn.jboss.org/repos/jbossas/projects/metadata/trunk/src/main/resources/dtd/jboss-web_5_0.dtdand shows an excerpt of the jboss-web_5_0.dtdThe most important bits are:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<literal>config-name</literal>: JBossWS endpoint config name (see <link linkend="JAX_WS_Endpoint_Configuration">JAX-WS_Endpoint_Configuration</link>)
</para>
</listitem>
<listitem>
<para>
<literal>config-file</literal>: JBossWS endpoint config file
</para>
</listitem>
<listitem>
<para>
<literal>wsdl-publish-location</literal>: Where to publish the runtime gnerated WSDL
</para>
</listitem>
</itemizedlist>
<para>
<programlisting>&lt;!ELEMENT webservice-description ( webservice-description-name, config-name?,
 config-file?, wsdl-publish-location? )&gt;&lt;!ELEMENT webservice-description-name ( #PCDATA )&gt;&lt;!ELEMENT wsdl-publish-location ( #PCDATA )&gt;</programlisting>
</para>

</section>
<section id="User_Guide_EJB3_endpoints"><title>EJB3 endpoints</title>
<para>
EJB deployment descriptor attributes are quiet the same. You can specify a top level <literal>webservices</literal> element along with you ejb declaration that allows you to override certain deployment aspects. The following excerpt is taken from https://anonsvn.jboss.org/repos/jbossas/projects/metadata/trunk/src/main/resources/dtd/jboss_5_0.dtd
</para>
<para>
In addition to the default properties that are customizable like in JSE deployments, the EJB descriptor allows you to specify:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<literal>context-root</literal>: A custom web context root. Applies to all beans in this deployment unit
</para>
</listitem>
</itemizedlist>
<para>
<programlisting>&lt;!ELEMENT webservices (context-root?, webservice-description*)&gt;&lt;!ELEMENT context-root (#PCDATA)&gt;&lt;!ELEMENT webservice-description ( webservice-description-name, config-name?,
 config-file?, wsdl-publish-location? )&gt;</programlisting>
</para>

</section>

</section>

</section>
<section id="User_Guide_Appendix_A"><title>Appendix A</title>
<para>
<link linkend="JAX_WS_Endpoint_Configuration">JAX-WS Endpoint Configuration</link>
</para>
<para>
<link linkend="JAX_WS_Client_Configuration">JAX-WS Client Configuration</link>
</para>
<para>
<link linkend="JAX_WS_Annotations">JAX-WS Annotations</link>
</para>

</section>
<section id="User_Guide_References"><title>References</title>
<para>
[1] <ulink url="http://www.jcp.org/en/jsr/detail?id=224"><citetitle>JSR-224 - Java API for XML-Based Web Services (JAX-WS) 2.0</citetitle></ulink>
</para>
<para>
[2] <ulink url="http://jaxb.dev.java.net"><citetitle>JSR 222 - Java Architecture for XML Binding (JAXB) 2.0</citetitle></ulink>
</para>
<para>
[3] <ulink url="http://www.jcp.org/en/jsr/detail?id=261"><citetitle>JSR-261 - Java API for XML Web Services Addressing</citetitle></ulink>
</para>
<para>
[4] <ulink url="http://www.w3.org/TR/soap12-part1"><citetitle>SOAP-1.2 - Messaging Framework</citetitle></ulink>
</para>
<para>
[5] <ulink url="http://jcp.org/en/jsr/detail?id=250"><citetitle>JSR-250 - Common Annotations for the Java Platform</citetitle></ulink>
</para>
<para>
[6] <ulink url="http://jcp.org/en/jsr/detail?id=181"><citetitle>JSR 181 - Web Services Metadata for the Java Platform</citetitle></ulink>
</para>
</section>
</article><article id="JBossWS_JAX_WS_Tools">
<title>JBossWS JAX-WS Tools</title>
<para>
The JAX-WS tools provided by JBossWS can be used in a variety of ways. First we will look at server-side development strategies, and then proceed to the client. 
</para>
<section id="JBossWS_JAX_WS_Tools_Server_side"><title>Server side</title>
<para>
When developing a Web Service Endpoint (the server-side) you have the option of starting from Java (bottom-up development), or from the abstact contract (WSDL) that defines your service (top-down development). If this is a new service (no existing contract), the bottom-up approach is the fastest route; you only need to add a few annotations to your classes to get a service up and running. However, if you are developing a service with an already defined contract, it is far simpler to use the top-down approach, since the provided tool will generate the annotated code for you.
</para>
<para>
Bottom-up use cases:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Exposing an already existing EJB3 bean as a Web Service
</para>
</listitem>
<listitem>
<para>
Providing a new service, and you want the contract to be generated for you
</para>
</listitem>
</itemizedlist>
<para>
Top-down use cases:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Replacing the implementation of an existing Web Service, and you can't break compatibility with older clients
</para>
</listitem>
<listitem>
<para>
Exposing a service that conforms to a contract specified by a third party (e.g. a vender that calls you back using an already defined protocol).
</para>
</listitem>
<listitem>
<para>
Creating a service that adheres to the XML Schema and WSDL you developed by hand up front
</para>
</listitem>
</itemizedlist>
<para>
The following JAX-WS command line tools are included in JBossWS:<table>
<title/><tgroup cols="2"><tbody><row>
<entry>
Command
</entry>
<entry>
Description
</entry>

</row>
<row>
<entry>
<link linkend="Wsprovide">wsprovide</link>
</entry>
<entry>
Generates JAX-WS portable artifacts, and provides the abstract contract. Used for bottom-up development.
</entry>

</row>
<row>
<entry>
<link linkend="Wsconsume">wsconsume</link>
</entry>
<entry>
Consumes the abstract contract (WSDL and Schema files), and produces artifacts for both a server and client. Used for top-down and client development
</entry>

</row>
<row>
<entry>
<link linkend="Wsrunclient">wsrunclient</link>
</entry>
<entry>
Executes a Java client (has a main method) using the JBossWS classpath.
</entry>

</row>
</tbody></tgroup>
</table>

</para>
<section id="JBossWS_JAX_WS_Tools_Bottom_Up__28Using_wsprovide_29"><title>Bottom-Up (Using wsprovide)</title>
<para>
The bottom-up strategy involves developing the Java code for your service, and then annotating it using JAX-WS annotations. These annotations can be used to customize the contract that is generated for your service. For example, you can change the operation name to map to anything you like. However, all of the annotations have sensible defaults, so only the @WebService annotation is required. 
</para>
<para>
This can be as simple as creating a single class:<programlisting>
package echo;

@javax.jws.WebService
public class Echo
{
 public String echo(String input)
 {
 return input;
 }
}
</programlisting>
</para>
<para>
A JSE or EJB3 deployment can be built using this class, and it is the only Java code needed to deploy on JBossWS. The WSDL, and all other Java artifacts called "wrapper classes" will be generated for you at deploy time. This actually goes beyond the JAX-WS specification, which requires that wrapper classes be generated using an offline tool. The reason for this requirement is purely a vender implementation problem, and since we do not believe in burdening a developer with a bunch of additional steps, we generate these as well. However, if you want your deployment to be portable to other application servers, you will unfortunately need to use a tool and add the generated classes to your deployment. 
</para>
<para>
This is the primary purpose of the <link linkend="Wsprovide">wsprovide</link> tool, to generate portable JAX-WS artifacts. Additionally, it can be used to "provide" the abstract contract (WSDL file) for your service. This can be obtained by invoking <link linkend="Wsprovide">wsprovide</link> using the "-w" option:
</para>
<para>
<programlisting>
$ javac -d . -classpath jboss-jaxws.jar Echo.java
$ wsprovide -w echo.Echo
Generating WSDL:
EchoService.wsdl
Writing Classes:
echo/jaxws/Echo.class
echo/jaxws/EchoResponse.class
</programlisting>
</para>
<para>
Inspecting the WSDL reveals a service called EchoService:<programlisting>&lt;service name='EchoService'&gt;&lt;port binding='tns:EchoBinding' name='EchoPort'&gt;&lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;&lt;/port&gt;&lt;/service&gt;</programlisting>
</para>
<para>
As expected, this service defines one operation, "echo":<programlisting>&lt;portType name='Echo'&gt;&lt;operation name='echo' parameterOrder='echo'&gt;&lt;input message='tns:Echo_echo'/&gt;&lt;output message='tns:Echo_echoResponse'/&gt;&lt;/operation&gt;&lt;/portType&gt;</programlisting>
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
Remember that <emphasis role="bold">when deploying on JBossWS you do not need to run this tool.</emphasis> You only need it for generating portable artifacts and/or the abstract contract for your service.
</para>
<para>
Let's create a POJO endpoint for deployment on JBoss AS. A simple web.xml needs to be created:<programlisting>&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
 version="2.4"&gt;&lt;servlet&gt;&lt;servlet-name&gt;Echo&lt;/servlet-name&gt;&lt;servlet-class&gt;echo.Echo&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;Echo&lt;/servlet-name&gt;&lt;url-pattern&gt;/Echo&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt;</programlisting>
</para>
<para>
The web.xml and the single class can now be used to create a war:<programlisting>
$ mkdir -p WEB-INF/classes
$ cp -rp echo WEB-INF/classes/
$ cp web.xml WEB-INF
$ jar cvf echo.war WEB-INF
added manifest
adding: WEB-INF/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/(in = 0) (out= 0)(stored 0%)
adding: WEB-INF/classes/echo/Echo.class(in = 340) (out= 247)(deflated 27%)
adding: WEB-INF/web.xml(in = 576) (out= 271)(deflated 52%)
</programlisting>
</para>
<para>
The war can then be deployed:<programlisting>
cp echo.war /usr/local/jboss-4.2.0.GA-ejb3/server/default/deploy
</programlisting>
</para>
<para>
This will internally invoke <link linkend="Wsprovide">wsprovide</link>, which will generate the WSDL. If deployment was successful, and you are using the default settings, it should be available here: http://localhost:8080/echo/Echo?wsdl
</para>
<para>
For a portable JAX-WS deployment, the wrapper classes generated earlier could be added to the deployment.
</para>

</section>
<section id="JBossWS_JAX_WS_Tools_Top_Down__28Using_wsconsume_29"><title>Top-Down (Using wsconsume)</title>
<para>
The top-down development strategy begins with the abstract contract for the service, which includes the WSDL file and zero or more schema files. The <link linkend="Wsconsume">wsconsume</link> tool is then used to consume this contract, and produce annotated Java classes (and optionally sources) that define it.
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
wsconsume seems to have a problem with symlinks on unix systems
</para>
<para>
Using the WSDL file from the bottom-up example, a new Java implementation that adheres to this service can be generated. The "-k" option is passed to <link linkend="Wsconsume">wsconsume</link> to preserve the Java source files that are generated, instead of providing just classes:
</para>
<para>
<programlisting> 
$ wsconsume -k EchoService.wsdl
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
</programlisting>
</para>
<para>
The following table shows the purpose of each generated file:<table>
<title/><tgroup cols="2"><tbody><row>
<entry>
File
</entry>
<entry>
Purpose
</entry>

</row>
<row>
<entry>
Echo.java
</entry>
<entry>
Service Endpoint Interface
</entry>

</row>
<row>
<entry>
Echo_Type.java
</entry>
<entry>
Wrapper bean for request message
</entry>

</row>
<row>
<entry>
EchoResponse.java
</entry>
<entry>
Wrapper bean for response message
</entry>

</row>
<row>
<entry>
ObjectFactory.java
</entry>
<entry>
JAXB XML Registry
</entry>

</row>
<row>
<entry>
package-info.java
</entry>
<entry>
Holder for JAXB package annotations
</entry>

</row>
<row>
<entry>
EchoService.java
</entry>
<entry>
Used only by JAX-WS clients
</entry>

</row>
</tbody></tgroup>
</table>

</para>
<para>
Examining the Service Endpoint Interface reveals annotations that are more explicit than in the class written by hand in the bottom-up example, however, these evaluate to the same contract:<programlisting>
@WebService(name = "Echo", targetNamespace = "http://echo/")
public interface Echo {
 @WebMethod
 @WebResult(targetNamespace = "")
 @RequestWrapper(localName = "echo", targetNamespace = "http://echo/", className = "echo.Echo_Type")
 @ResponseWrapper(localName = "echoResponse", targetNamespace = "http://echo/", className = "echo.EchoResponse")
 public String echo(
 @WebParam(name = "arg0", targetNamespace = "")
 String arg0);

}
</programlisting>
</para>
<para>
The only missing piece (besides the packaging) is the implementation class, which can now be written, using the above interface.<programlisting>
package echo;

@javax.jws.WebService(endpointInterface="echo.Echo")
public class EchoImpl implements Echo
{
 public String echo(String arg0)
 {
 return arg0;
 }
}
</programlisting>
</para>

</section>

</section>
<section id="JBossWS_JAX_WS_Tools_Client_Side"><title>Client Side</title>
<para>
Before going to detail on the client-side it is important to understand the decoupling concept that is central to Web Services. Web Services are not the best fit for internal RPC, even though they can be used in this way. There are much better technologies for this (CORBA, and RMI for example). Web Services were designed specifically for interoperable coarse-grained correspondence. There is no expectation or guarantee that any party participating in a Web Service interaction will be at any particular location, running on any particular OS, or written in any particular programming language. So because of this, it is important to clearly separate client and server implementations. The only thing they should have in common is the abstract contract definition. If, for whatever reason, your software does not adhere to this principal, then you should not be using Web Services. For the above reasons, the <emphasis role="bold"><emphasis>recommended methodology for developing a client is</emphasis></emphasis> to follow <emphasis role="bold"><emphasis>the top-down approach</emphasis></emphasis>, even if the client is running on the same server.
</para>
<para>
Let's repeat the process of the top-down section, although using the deployed WSDL, instead of the one generated offline by <link linkend="Wsprovide">wsprovide</link>. The reason why we do this is just to get the right value for soap:address. This value must be computed at deploy time, since it is based on container configuration specifics. You could of course edit the WSDL file yourself, although you need to ensure that the path is correct.
</para>
<para>
Offline version:<programlisting>&lt;service name='EchoService'&gt;&lt;port binding='tns:EchoBinding' name='EchoPort'&gt;&lt;soap:address location='REPLACE_WITH_ACTUAL_URL'/&gt;&lt;/port&gt;&lt;/service&gt;</programlisting>
</para>
<para>
Online version:<programlisting>&lt;service name="EchoService"&gt;&lt;port binding="tns:EchoBinding" name="EchoPort"&gt;&lt;soap:address location="http://localhost.localdomain:8080/echo/Echo"/&gt;&lt;/port&gt;&lt;/service&gt;</programlisting>
</para>
<para>
Using the online deployed version with <link linkend="Wsconsume">wsconsume</link>:<programlisting>
$ wsconsume -k http://localhost:8080/echo/Echo?wsdl
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
echo/Echo.java
echo/EchoResponse.java
echo/EchoService.java
echo/Echo_Type.java
echo/ObjectFactory.java
echo/package-info.java
</programlisting>
</para>
<para>
The one class that was not examined in the top-down section, was EchoService.java. Notice how it stores the location the WSDL was obtained from. <programlisting>
@WebServiceClient(name = "EchoService", targetNamespace = "http://echo/", wsdlLocation = "http://localhost:8080/echo/Echo?wsdl")
public class EchoService extends Service
{
 private final static URL ECHOSERVICE_WSDL_LOCATION;

 static {
 URL url = null;
 try {
 url = new URL("http://localhost:8080/echo/Echo?wsdl");
 } catch (MalformedURLException e) {
 e.printStackTrace();
 }
 ECHOSERVICE_WSDL_LOCATION = url;
 }

 public EchoService(URL wsdlLocation, QName serviceName) {
 super(wsdlLocation, serviceName);
 }

 public EchoService() {
 super(ECHOSERVICE_WSDL_LOCATION, new QName("http://echo/", "EchoService"));
 }

 @WebEndpoint(name = "EchoPort")
 public Echo getEchoPort() {
 return (Echo)super.getPort(new QName("http://echo/", "EchoPort"), Echo.class);
 }
}
</programlisting>
</para>
<para>
As you can see, this generated class extends the main client entry point in JAX-WS, javax.xml.ws.Service. While you can use Service directly, this is far simpler since it provides the configuration info for you. The only method we really care about is the getEchoPort() method, which returns an instance of our Service Endpoint Interface. Any WS operation can then be called by just invoking a method on the returned interface.
</para>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
It's not recommended to refer to a remote WSDL URL in a production application. This causes network I/O every time you instantiate the Service Object. Instead, use the tool on a saved local copy, or use the URL version of the constructor to provide a new WSDL location.
</para>
<para>
All that is left to do, is write and compile the client:<programlisting>
import echo.*;

public class EchoClient
{
 public static void main(String args[])
 {
 if (args.length != 1)
 {
 System.err.println("usage: EchoClient &lt;message&gt;");
 System.exit(1);
 }
 
 EchoService service = new EchoService();
 Echo echo = service.getEchoPort();
 System.out.println("Server said: " + echo.echo(args[0]));
 } 
}
</programlisting>
</para>
<para>
It can then be easily executed using the <link linkend="Wsrunclient">wsrunclient</link> tool. This is just a convenience tool that invokes java with the needed classpath:<programlisting>
$ wsrunclient EchoClient 'Hello World!'
Server said: Hello World!
</programlisting>
</para>
<para>
It is easy to change the endpoint address of your operation at runtime, setting the ENDPOINT_ADDRESS_PROPERTY as shown below:<programlisting>
...
 EchoService service = new EchoService();
 Echo echo = service.getEchoPort();

 /* Set NEW Endpoint Location */
 String endpointURL = "http://NEW_ENDPOINT_URL";
 BindingProvider bp = (BindingProvider)echo;
 bp.getRequestContext().put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, endpointURL);

 System.out.println("Server said: " + echo.echo(args[0]));
...
</programlisting>
</para>

</section>
<section id="JBossWS_JAX_WS_Tools_Command_line_"><title>Command-line &amp; Ant Task Reference</title>
<itemizedlist mark="opencircle"><listitem>
<para>
<link linkend="Wsconsume">wsconsume reference page</link>
</para>
</listitem>
<listitem>
<para>
<link linkend="Wsprovide">wsprovide reference page</link>
</para>
</listitem>
<listitem>
<para>
<link linkend="Wsrunclient">wsrunclient reference page</link>
</para>
</listitem>
</itemizedlist>

</section>
<section id="JBossWS_JAX_WS_Tools_JAX_WS_binding_customization"><title>JAX-WS binding customization</title>
<para>
An introduction to binding customizations:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
http://java.sun.com/webservices/docs/2.0/jaxws/customizations.html
</para>
</listitem>
</itemizedlist>
<para>
The schema for the binding customization files can be found here:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
https://jax-ws.dev.java.net/source/browse/jax-ws/guide/docs/wsdl-customization.xsd?rev=1.2&amp;view=log
</para>
</listitem>
</itemizedlist>
<para>
Category:Tools (Category:Tools)Category:Start from scratch (Category:Start from scratch)
</para>
</section>
</article><article id="Authentication">
<title>Authentication</title>
<para>
Category:Transition / staging (Category:Transition / staging)This page explains the simplest way to authenticate a web service user with JBossWS.
</para>
<para>
First we secure the access to the SLSB as we would do for normal (non web service) invocations: this can be easily done through the @RolesAllowed, @PermitAll, @DenyAll annotation. The allowed user roles can be set with these annotations both on the bean class and on any of its business methods.
</para>
<para>
<programlisting>
@Stateless
@RolesAllowed("friend")
public class EndpointEJB implements EndpointInterface
{
 ...
}
</programlisting>
</para>
<para>
Similarly POJO endpoints are secured the same way as we do for normal web applications in web.xml:
</para>
<para>
<programlisting>&lt;security-constraint&gt;&lt;web-resource-collection&gt;&lt;web-resource-name&gt;All resources&lt;/web-resource-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/web-resource-collection&gt;&lt;auth-constraint&gt;&lt;role-name&gt;friend&lt;/role-name&gt;&lt;/auth-constraint&gt;&lt;/security-constraint&gt;&lt;security-role&gt;&lt;role-name&gt;friend&lt;/role-name&gt;&lt;/security-role&gt;</programlisting>
</para>
<section id="Authentication_Define_the_security_domain"><title>Define the security domain</title>
<para>
Next, define the security domain for this deployment. This is performed using the <link linkend="User_Guide_SecurityDomain">@SecurityDomain</link> annotation for EJB3 endpoints
</para>
<para>
<programlisting>
@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
public class EndpointEJB implements EndpointInterface
{
 ...
}
</programlisting>
</para>
<para>
or modifying the jboss-web.xml for POJO endpoints
</para>
<para>
<programlisting>&lt;jboss-web&gt;&lt;security-domain&gt;java:/jaas/JBossWS&lt;/security-domain&gt;&lt;/jboss-web&gt;</programlisting>
</para>
<para>
The JBossWS security context is configured in login-config.xml and uses the <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=UsersRolesLoginModule"><citetitle>UsersRolesLoginModule</citetitle></ulink>. As a matter of fact login-config.xml, that lives in the server config dir, contains this security domain definition:
</para>
<para>
<programlisting>&lt;application-policy name="JBossWS"&gt;&lt;authentication&gt;&lt;login-module code="org.jboss.security.auth.spi.UsersRolesLoginModule"
 flag="required"&gt;&lt;module-option name="usersProperties"&gt;props/jbossws-users.properties&lt;/module-option&gt;&lt;module-option name="rolesProperties"&gt;props/jbossws-roles.properties&lt;/module-option&gt;&lt;module-option name="unauthenticatedIdentity"&gt;anonymous&lt;/module-option&gt;&lt;/login-module&gt;&lt;/authentication&gt;&lt;/application-policy&gt;</programlisting>
</para>
<para>
Of course you can define and use your own security domain as well as your login module (in order to check for users' identity querying a database for example).
</para>

</section>
<section id="Authentication_Use_BindingProvider_to_set_principal_2Fcredential"><title>Use BindingProvider to set principal/credential</title>
<para>
A web service client may use the javax.xml.ws.BindingProvider interface to set the username/password combination
</para>
<para>
<programlisting>
URL wsdlURL = new File("resources/jaxws/samples/context/WEB-INF/wsdl/TestEndpoint.wsdl").toURL();
QName qname = new QName("http://org.jboss.ws/jaxws/context", "TestEndpointService");
Service service = Service.create(wsdlURL, qname);
port = (TestEndpoint)service.getPort(TestEndpoint.class);

BindingProvider bp = (BindingProvider)port;
bp.getRequestContext().put(BindingProvider.USERNAME_PROPERTY, "kermit");
bp.getRequestContext().put(BindingProvider.PASSWORD_PROPERTY, "thefrog");
</programlisting>
</para>

</section>
<section id="Authentication_Using_HTTP_Basic_Auth_for_security"><title>Using HTTP Basic Auth for security</title>
<para>
To enable HTTP Basic authentication you use the <link linkend="User_Guide_WebContext">@WebContext</link> annotation on the bean class
</para>
<para>
<programlisting>
@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
@WebContext(contextRoot="/my-cxt", urlPattern="/*", authMethod="BASIC", transportGuarantee="NONE", secureWSDLAccess=false)
public class EndpointEJB implements EndpointInterface
{
 ...
}
</programlisting>
</para>
<para>
For POJO endpoints, we modify the web.xml adding the auth-method element:
</para>
<para>
<programlisting>&lt;login-config&gt;&lt;auth-method&gt;BASIC&lt;/auth-method&gt;&lt;realm-name&gt;Test Realm&lt;/realm-name&gt;&lt;/login-config&gt;</programlisting>
</para>
</section>
</article><article id="Secure_transport">
<title>Secure transport</title>
<para>
Category:Transition / staging (Category:Transition / staging)JBossWS allows you to require that requests to a given endpoint use SSL by specifying the <emphasis>transportGuarantee</emphasis> attribute in the <link linkend="User_Guide_WebContext">@WebContext</link> annotation.
</para>
<para>
Here is an example using a SLSB endpoint:<programlisting>
@Stateless
@SecurityDomain("JBossWS")
@RolesAllowed("friend")
@WebContext(contextRoot="/my-cxt", urlPattern="/*", authMethod="BASIC", transportGuarantee="CONFIDENTIAL", secureWSDLAccess=false)
public class EndpointEJB implements EndpointInterface
{
 ...
}
</programlisting>
</para>
<para>
Similarly to enforce the same requirement on POJO endpoints, you need to edit web.xml and add a user-data-constraint element to your security-constraint element:
</para>
<para>
<programlisting>&lt;security-constraint&gt;&lt;web-resource-collection&gt;&lt;web-resource-name&gt;All resources&lt;/web-resource-name&gt;&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/web-resource-collection&gt;&lt;auth-constraint&gt;&lt;role-name&gt;friend&lt;/role-name&gt;&lt;/auth-constraint&gt;&lt;user-data-constraint&gt;&lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;&lt;/user-data-constraint&gt;&lt;/security-constraint&gt;&lt;security-role&gt;&lt;role-name&gt;friend&lt;/role-name&gt;&lt;/security-role&gt;</programlisting>
</para>
<para>
If you're manually creating your service contract, make sure that the endpoint address in your WSDL file uses a secure protocol. The easiest way is to add "https://" to the SOAP Address entry:
</para>
<para>
<programlisting>&lt;service name="MyService"&gt;&lt;port name="BasicSecuredPort" binding="tns:MyBinding"&gt;&lt;soap:address location="https://localhost:8443/my-ctx/SecureEndpoint"/&gt;&lt;/port&gt;&lt;/service&gt;</programlisting>
</para>
<para>
For this to work the Tomcat+SSL connector must be enabled:
</para>
<para>
<programlisting>&lt;Connector port="8443" address="${jboss.bind.address}"
 maxThreads="100" minSpareThreads="5" maxSpareThreads="15"
 scheme="https" secure="true" clientAuth="want"
 keystoreFile="${jboss.server.home.dir}/conf/keystores/wsse.keystore" 
 keystorePass="jbossws"
 truststoreFile="${jboss.server.home.dir}/conf/keystores/wsse.keystore" 
 truststorePass="jbossws"
 sslProtocol = "TLS" /&gt;</programlisting>
</para>
<para>
Please refer the <ulink url="http://tomcat.apache.org/tomcat-5.5-doc/ssl-howto.html"><citetitle>Tomcat-5.5 SSL Configuration HOWTO</citetitle></ulink> for further details.
</para>
<section id="Secure_transport_Client_side"><title>Client side</title>
<para>
On the client side the truststore must be installed:
</para>
<para>
<programlisting>&lt;sysproperty key="javax.net.ssl.keyStore" value="${test.resources.dir}/wsse/wsse.keystore"/&gt;&lt;sysproperty key="javax.net.ssl.trustStore" value="${test.resources.dir}/wsse/wsse.truststore"/&gt;&lt;sysproperty key="javax.net.ssl.keyStorePassword" value="jbossws"/&gt;&lt;sysproperty key="javax.net.ssl.trustStorePassword" value="jbossws"/&gt;&lt;sysproperty key="javax.net.ssl.keyStoreType" value="jks"/&gt;&lt;sysproperty key="javax.net.ssl.trustStoreType" value="jks"/&gt;</programlisting>
</para>
<para>
As you can see, this requires you to setup the environment specifying both the location and type of your truststore.
</para>
<para>
Finally, in case you see the following exception:
</para>
<para>
<programlisting>
 java.io.IOException: HTTPS hostname wrong: should be &lt;localhost&gt;
 at sun.net.www.protocol.https.HttpsClient.checkURLSpoofing(HttpsClient.java:493)
 at sun.net.www.protocol.https.HttpsClient.afterConnect(HttpsClient.java:418)
</programlisting>
</para>
<para>
you should disable URL checking on the client side:
</para>
<para>
<programlisting>&lt;sysproperty key="org.jboss.security.ignoreHttpsHost" value="true"/&gt;</programlisting>
</para>
</section>
</article><article id="JAX_WS_Endpoint_Configuration">
<title>JAX-WS Endpoint Configuration</title>
<para>
Category:Development (Category:Development)The standard endpoint configuration is defined in <emphasis role="bold">standard-jaxws-endpoint-config.xml</emphasis>
</para>
<section id="JAX_WS_Endpoint_Configuration_Using__40EndpointConfig"><title>Using @EndpointConfig</title>
<para>
On the server side you proabably use the <literal>@EndpointConfig</literal> annotation to specify one of the available (might be custom as well) configurations:
</para>
<para>
<programlisting>
@WebService(name = "Hello", serviceName = "HelloService", targetNamespace = "http://org.jboss.ws/samples/wssecurity")
@EndpointConfig(configName = "Standard WSSecurity Endpoint") (1)
@SOAPBinding(style = SOAPBinding.Style.RPC)
public class HelloJavaBean
{
 private Logger log = Logger.getLogger(HelloJavaBean.class);

 @WebMethod
 public UserType echoUserType(@WebParam(name = "user") UserType in0)
 {
 log.info(in0);
 return in0;
 }
}

</programlisting>
</para>
<orderedlist numeration="arabic"><listitem>
<para>
@EndpointConfig(configName = "Standard WSSecurity Endpoint")
</para>
</listitem>
</orderedlist>

</section>
<section id="JAX_WS_Endpoint_Configuration_Configuration_presets"><title>Configuration presets</title>
<section id="JAX_WS_Endpoint_Configuration_Standard_Endpoint"><title>Standard Endpoint</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;endpoint-config&gt;&lt;config-name&gt;Standard Endpoint&lt;/config-name&gt;&lt;/endpoint-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>

</section>
<section id="JAX_WS_Endpoint_Configuration_Standard_WSAddressing_Endpoint"><title>Standard WSAddressing Endpoint</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;endpoint-config&gt;&lt;config-name&gt;Standard WSAddressing Endpoint&lt;/config-name&gt;&lt;pre-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP11_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;WSAddressing Handler&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.ws.extensions.addressing.jaxws.WSAddressingServerHandler&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/pre-handler-chains&gt;&lt;/endpoint-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>
<para>
Since 2.0.3
</para>

</section>
<section id="JAX_WS_Endpoint_Configuration_Standard_SOAP_1_2_WSAddressing_Endpoint"><title>Standard SOAP 1.2 WSAddressing Endpoint</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;endpoint-config&gt;&lt;config-name&gt;Standard SOAP 1.2 WSAddressing Endpoint&lt;/config-name&gt;&lt;post-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP12_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;WSAddressing Handler&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.ws.extensions.addressing.jaxws.WSAddressingServerHandler&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/post-handler-chains&gt;&lt;/endpoint-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>

</section>
<section id="JAX_WS_Endpoint_Configuration_Standard_WSSecurity_Endpoint"><title>Standard WSSecurity Endpoint</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;endpoint-config&gt;&lt;config-name&gt;Standard WSSecurity Endpoint&lt;/config-name&gt;&lt;pre-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP11_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;WSSecurity Handler&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.ws.extensions.security.jaxws.WSSecurityHandlerServer&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/pre-handler-chains&gt;&lt;/endpoint-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>
</section>

</section>
</article><article id="JAX_WS_Client_Configuration">
<title>JAX-WS Client Configuration</title>
<para>
Category:Development (Category:Development)The standard client configuration is defined in <emphasis role="bold">standard-jaxws-client-config.xml</emphasis>
</para>
<section id="JAX_WS_Client_Configuration_Client_side_port_configuration"><title>Client side port configuration</title>
<para>
You can use stub properties on the client side to chose from one of the configuration presets:
</para>
<para>
<programlisting>
 Hello endpoint = service.getPort(Hello.class);
((StubExt) endpoint).setConfigName("Standard WSSecurity Client");
</programlisting>
</para>

</section>
<section id="JAX_WS_Client_Configuration_Available_configuration"><title>Available configuration</title>
<section id="JAX_WS_Client_Configuration_Standard_Client"><title>Standard Client</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;client-config&gt;&lt;config-name&gt;Standard Client&lt;/config-name&gt;&lt;/client-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>

</section>
<section id="JAX_WS_Client_Configuration_Standard_WSAddressing_Client"><title>Standard WSAddressing Client</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;client-config&gt;&lt;config-name&gt;Standard WSAddressing Client&lt;/config-name&gt;&lt;post-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP11_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;WSAddressing Handler&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.ws.extensions.addressing.jaxws.WSAddressingClientHandler&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/post-handler-chains&gt;&lt;/client-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>
<para>
Since 2.0.3
</para>

</section>
<section id="JAX_WS_Client_Configuration_Standard_SOAP_1_2_WSAddressing_Client"><title>Standard SOAP 1.2 WSAddressing Client</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;client-config&gt;&lt;config-name&gt;Standard SOAP 1.2 WSAddressing Client&lt;/config-name&gt;&lt;post-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP12_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;WSAddressing Handler&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.ws.extensions.addressing.jaxws.WSAddressingClientHandler&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/post-handler-chains&gt;&lt;/client-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>

</section>
<section id="JAX_WS_Client_Configuration_Standard_WSSecurity_Client"><title>Standard WSSecurity Client</title>
<para>
<programlisting>&lt;jaxws-config xmlns="urn:jboss:jaxws-config:2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:javaee="http://java.sun.com/xml/ns/javaee"
 xsi:schemaLocation="urn:jboss:jaxws-config:2.0 jaxws-config_2_0.xsd"&gt;&lt;client-config&gt;&lt;config-name&gt;Standard WSSecurity Client&lt;/config-name&gt;&lt;post-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP11_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;WSSecurityHandlerOutbound&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.ws.extensions.security.jaxws.WSSecurityHandlerClient&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/post-handler-chains&gt;&lt;/client-config&gt;&lt;/jaxws-config&gt;</programlisting>
</para>
</section>

</section>
</article><article id="Endpoint_management">
<title>Endpoint management</title>
<para>
Category:Production (Category:Production)JBossWS registers MBeans that users can leverage to manage every webservice endpoint. Apart from the obvious start/stop functionalities, they provide valuable information and statistics about messages processed by the endpoints.
</para>
<section id="Endpoint_management_Getting_the_information"><title>Getting the information</title>
<para>
JBoss ships with a JMX-Console with all the application server MBeans. It is usually available at URL http://localhost:8080/jmx-console. For endpoint management you might be interested in the MBeans belonging to the jboss.ws domain.
</para>
<para>
The application server also has an applet based web-console which basically has the same data as the JMX-Console plus some advanced features including snapshot graphics.
</para>
<para>
Of course you can access an MBean programmatically too. Please refer to the <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=FAQJBossJMX"><citetitle>JBoss JMX faq</citetitle></ulink> for further details; here is a brief code snippet you might want to start from in order to access a ManagedEndpointMBean from the same virtual machine:<programlisting>
try
{
 MBeanServer server = MBeanServerLocator.locate();
 ManagedEndpointMBean mep = (ManagedEndpointMBean)MBeanProxyExt.create(
 ManagedEndpointMBean.class,
 "jboss.ws:context=my-ctx,endpoint=MyEndpoit",
 server);
 ...
}
catch (Exception e)
{
 e.printStackTrace();
}
</programlisting>
</para>

</section>
<section id="Endpoint_management_Metrics"><title>Metrics</title>
<para>
For each deployed endpoint you'll find an <emphasis>org.jboss.wsf.framework.management.ManagedEndpoint</emphasis> MBean providing basic start/stop functionalities and metrics. Calling a stopped endpoint will always result in a SOAP fault message.
</para>
<para>
The metrics available for each managed endpoint are:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Min, max, average and total processing time: processing includes both the WS stack plus application server work and the user business logic
</para>
</listitem>
<listitem>
<para>
Last start and stop time
</para>
</listitem>
<listitem>
<para>
Request, response and fault count
</para>
</listitem>
</itemizedlist>

</section>
<section id="Endpoint_management_Records"><title>Records</title>
<para>
Since 2.0.3JBossWS features a highly configurable records' collection and management system. Each record is basically composed of a message plus additional information (for example the caller address and the called endpoint operation).Endpoints can be configured with record processors that are invoked whenever a message flow is detected and records are thus created.
</para>
<para>
Every deployed endpoint is configured with default record processors. However custom processors as well as record filters can be easily plugged in and managed at any time through JMX. This gives users the chance of performing advanced analysis of the webservice traffic according to their business requirements.
</para>
<para>
Please refer to the <link linkend="Records_management">records management page</link> for further details.
</para>

</section>
<section id="Endpoint_management_Snapshots_and_threshold_monitors"><title>Snapshots and threshold monitors</title>
<para>
As previously said, the <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=WebConsole"><citetitle>JBoss Web Console</citetitle></ulink> has interesting features including <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=WebConsoleSnapshots"><citetitle>snapshots</citetitle></ulink> and <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=WebConsoleMonitoring"><citetitle>threshold monitors</citetitle></ulink>. 
</para>
<para>
Snapshots allow users to record changes of a given MBean attribute within a defined time interval. Data are sampled at a given rate and may be plotted to graphs with a few clicks. Snapshots are listed in the Web console and can be created simply browsing to http://localhost:8080/web-console/createSnapshot.jsp .
</para>
<para>
Threshold monitors allow users to be notified whenever a given MBean attribute exceed a certain range of values. The threshold monitor's creation and management processes are similar to those mentioned above for the snapshots. Simply browse to http://localhost:8080/web-console/createThresholdMonitor.jsp .
</para>
<para>
Speaking of WS availability and SLA, this all becomes interesting because users can monitor and take snapshots of critical attributes like the average/max processing time of a managed endpoint. Moreover, advanced analysis can be performed leveraging ad-hoc attributes of custom record processors.
</para>
</section>
</article><article id="Records_management">
<title>Records management</title>
<para>
Category:Production (Category:Production)Since 2.0.3JBossWS records' collection and management system gives administrators a means of performing custom analysis of their webservice traffic as well as exporting communication logs.
</para>
<section id="Records_management_What_is_recorded"><title>What is recorded</title>
<para>
Each record is basically composed of a message plus additional information; here are the current record attributes:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Creation date
</para>
</listitem>
<listitem>
<para>
Source host
</para>
</listitem>
<listitem>
<para>
Destination host
</para>
</listitem>
<listitem>
<para>
Message type (in/out)
</para>
</listitem>
<listitem>
<para>
Invoked endpoint operation
</para>
</listitem>
<listitem>
<para>
Message envelope (including both soap:header and soap:body for SOAP messages)
</para>
</listitem>
<listitem>
<para>
Http headers
</para>
</listitem>
<listitem>
<para>
Record group ID (allowing records belonging to the same message flow to be linked together)
</para>
</listitem>
</itemizedlist>
<para>
Of course records may also have meaningful values for a subset of the afore mentioned record attributes.
</para>

</section>
<section id="Records_management_Use_cases"><title>Use cases</title>
<para>
What are records useful for? In spite of <link linkend="Endpoint_management_Metrics">endpoint metrics</link> that provide response time information and counts of invocations, records provide users with rich data about the content of the exchanged messages and their sender/receiver. The record system allows fine grained management and is customizable according to the users need; some of the use cases supported by the default configuration are:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Logging request and response messages: being able to record messages received from and sent to a given service consumer without stopping the provider may be really useful. You just need to set the <emphasis>recording</emphasis> attribute of their endpoint's LogRecorder to true. The added value of this logging solution comes from the use of filters through which messages coming from a given address and related to a given wsdl operation only can be logged.
</para>
</listitem>
<listitem>
<para>
Accountability: service providers may want to know which consumers are actually hitting a given service. This can be done for example using the <emphasis>getClientHosts</emphasis> functionality of the MemoryBufferRecorder once it has been switched to recording state.
</para>
</listitem>
<listitem>
<para>
Getting statistics, filtering records: service administrators might want to see the last records related to a given endpoint or operation, the last records related to messages coming from a given customer and the response the system gave them, etc. These information can be obtained using the <emphasis>getRecordsByOperation</emphasis>, <emphasis>getRecordsByClientHost</emphasis> or the more general <emphasis>getMatchingRecords</emphasis> functionality of the MemoryBufferRecorder.
</para>
</listitem>
</itemizedlist>

</section>
<section id="Records_management_How_it_works_and_how_to_use_it"><title>How it works and how to use it</title>
<para>
The recording system is composed of
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
JAX-WS handlers intercepting inbound and outbound communication
</para>
</listitem>
<listitem>
<para>
Record processors plugged into deployed endpoints; handlers collect records and send them to every processors through the current endpoint. Processors may store records, convert them, log them, ...
</para>
</listitem>
<listitem>
<para>
MBean views of processors that can be used to configure and fine tune recording at runtime
</para>
</listitem>
<listitem>
<para>
Record filters allowing selection of information to be recorded as well as providing means of performing custom queries on the saved records.
</para>
</listitem>
</itemizedlist>
<section id="Records_management_Server_side"><title>Server side</title>
<para>
On server side records are collected by JAX-WS handlers and passed to the configured processors. JBossWS comes with two default record processors that are plugged into every endpoint during the deployment:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
LogRecorder: a simple record processor that writes records to the configured log.
</para>
</listitem>
<listitem>
<para>
MemoryBufferRecorder: a record processor that keeps the last received records in memory and allows user to search / get statistics on them.
</para>
</listitem>
</itemizedlist>
<para>
Every processors can be fine tuned to process some record attributes only according to the user and/or performance requirements. Default processors are not in recording mode upon creation, thus you need to switch them to recording mode through their MBean interfaces (see the <emphasis>Recording</emphasis> flag in the jmx-console).
</para>
<para>
Common processor properties and their respective defaults values are:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
processDestinationHost (true)
</para>
</listitem>
<listitem>
<para>
processSourceHost (true)
</para>
</listitem>
<listitem>
<para>
processHeaders (true)
</para>
</listitem>
<listitem>
<para>
processEnvelope (true)
</para>
</listitem>
<listitem>
<para>
processMessageType (true)
</para>
</listitem>
<listitem>
<para>
processOperation (true)
</para>
</listitem>
<listitem>
<para>
processDate (true)
</para>
</listitem>
<listitem>
<para>
recording (false)
</para>
</listitem>
</itemizedlist>
<para>
The recorders can be configured in the stacks bean configuration
</para>
<para>
<programlisting>&lt;bean name="WSMemoryBufferRecorder" class="org.jboss.wsf.framework.management.recording.MemoryBufferRecorder"&gt;&lt;property name="recording"&gt;false&lt;/property&gt;&lt;/bean&gt;&lt;bean name="WSLogRecorder" class="org.jboss.wsf.framework.management.recording.LogRecorder"&gt;&lt;property name="recording"&gt;false&lt;/property&gt;&lt;/bean&gt;</programlisting>The recording system is available for all the JBossWS supported stacks. However slightly different procedure is required to enable it depending on the used stack.
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Native stack
</para>
</listitem>
</itemizedlist>
<para>
Native stack comes with <link linkend="JAX_WS_Endpoint_Configuration">preset endpoint configurations</link>. The default standard endpoint already has the server side recording handler:<programlisting>&lt;endpoint-config&gt;&lt;config-name&gt;Standard Endpoint&lt;/config-name&gt;&lt;pre-handler-chains&gt;&lt;javaee:handler-chain&gt;&lt;javaee:protocol-bindings&gt;##SOAP11_HTTP&lt;/javaee:protocol-bindings&gt;&lt;javaee:handler&gt;&lt;javaee:handler-name&gt;Recording Handler&lt;/javaee:handler-name&gt;&lt;javaee:handler-class&gt;org.jboss.wsf.framework.invocation.RecordingServerHandler&lt;/javaee:handler-class&gt;&lt;/javaee:handler&gt;&lt;/javaee:handler-chain&gt;&lt;/pre-handler-chains&gt;&lt;/endpoint-config&gt;</programlisting>thus nothing is required to use it since it is automatically installed in the pre-handler-chain. Of course you might want to add it to other endpoint configurations you're using.
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Metro and CXF stacks
</para>
</listitem>
</itemizedlist>
<para>
Other stacks require users to manually add the <emphasis>org.jboss.wsf.framework.invocation.RecordingServerHandler</emphasis> to their endpoint handler chain. This can be done <link linkend="User_Guide_Handler_Framework">the same way common user handlers are added</link>.
</para>
<para>
Once the handler is properly added to the chain, log recording configuration is agnostic to the used stack. Users just need to tune the processors parameters though their MBean interfaces.
</para>

</section>
<section id="Records_management_Client_side"><title>Client side</title>
<para>
JMX management of processors is of course available on server side only. However users might also be interested in collecting and processing records on client side. Since handlers can be set on client side too, customer handlers could be configured to capture messages almost like the <emphasis>RecordingServerHandler</emphasis> does. This is left to the users since it is directly linked to their custom needs. For instance a common use could be to pass client side collected records to the LogRecorder.
</para>

</section>

</section>
<section id="Records_management_Advanced_hints"><title>Advanced hints</title>
<section id="Records_management_Adding_custom_recorders"><title>Adding custom recorders</title>
<para>
As previously said, the recording system is extensible: JBossWS users can write their own processors and plug them at runtime into their deployed endpoints through the <emphasis>addRecordProcessor</emphasis> functionality of the ManagedEndpoint MBean. Every processor needs to implement the <emphasis>org.jboss.wsf.spi.management.recording.RecordProcessor</emphasis> interface. Then you can choose one of the two following options:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Give you record processor an MBean interface declaring the manageable attributes: the recording system will plug your processor to the endpoint and register a management MBean for it using your interface. This allows you to create highly configurable custom processors. For an example of this development option, take a look at the <emphasis>org.jboss.wsf.framework.management.recording.MemoryBufferRecorder</emphasis>.
</para>
</listitem>
<listitem>
<para>
Add your record processor to the managed endpoint as is: the recording system will plug it to the endpoint and register a standard management MBean for its basic processing configuration. The <emphasis>org.jboss.wsf.framework.management.recording.LogRecorder</emphasis> is an example of this development option.
</para>
</listitem>
</itemizedlist>
<para>
A code snippet showing how to get the MBeanProxy instance which you can invoke MBean with can be found <link linkend="Endpoint_management_Getting_the_information">here</link>.
</para>

</section>
<section id="Records_management_Handler_27s_position"><title>Handler's position</title>
<para>
Of course the recording handler's position in the handler chain influences the collected records. As a matter of fact some information may or may not be available at a given point of the handler chain execution. The standard endpoint configuration declares the RecordingServerHandler into the pre-handler-chain. Speaking of the native stack, this means for example that you'll get the invoked operation data and that decrypted messages will be recorded if using WS-Security, since the WS-Security handler runs in the post-handler-chain. Users might want to change the recording handler's position in the chain according to their requirements.
</para>

</section>
<section id="Records_management_Multiple_handlers"><title>Multiple handlers</title>
<para>
Records attributes include a record group ID that is meant to link records whose messages belong to the same message flow (a request-response for example). In order to set the right group ID to the records, the current ID is associated to the thread that is processing the endpoint invocation. This means that multiple related records can be linked together and extracted together from a processor.
</para>
<para>
For this reason, you might want to install multiple recording handlers into different points of the handler chain. For instance, it could make sense to record messages both before and after encryption/decryption when using WS-Security.
</para>

</section>

</section>
<section id="Records_management_Future_extensions"><title>Future extensions</title>
<para>
This paragraph covers eventual future extensions and/or idea JBossWS users may want to leverage for their own business.
</para>
<section id="Records_management_Database_recorder"><title>Database recorder</title>
<para>
The MemoryBufferRecorder provides interesting functionalities to query the collected records set. For obvious reasons, records are discarded once a given size of the buffer is reached.
</para>
<para>
A DB based recorder could be developed; it should work the same way the MemoryBufferRecorder does, except for records that should be saved through a given datasource. This will provide persistence of data even in case of application server reboot and webservice application redeploy. It will also allow records coming from different node of a cluster to be stored together. Finally this would allow administrators to directly query the database, which might be far more efficient.
</para>

</section>
<section id="Records_management_Custom_log_writer"><title>Custom log writer</title>
<para>
The idea of getting statistics from collected records could be further exploited getting custom logs from the records. These logs could be outputted by a custom processor in standard or proprietary formats allowing them to be imported into eventual third-party log processing tools which might offer complex/funky graphic or statistic functionalities and so on.
</para>

</section>

</section>
<section id="Records_management_References"><title>References</title>
<para>
You might want to take a look at the <emphasis>org.jboss.wsf.framework.management.recording</emphasis> and <emphasis>org.jboss.wsf.spi.management.recording</emphasis> packages in the source code to better understand how all this works and can be used.
</para>
</section>
</article><article id="WS_Security_options">
<title>WS-Security options</title>
<para>
Category:Production (Category:Production)Category:Transition / staging (Category:Transition / staging)JBossWS implements WS-Security 1.0 specifications to provide users with message level security. The user guide explains <link linkend="User_Guide_WS_Security">how to configure WS-Security</link> through declaration files and annotations; for this aim, a simple example shows how to sign (and require signature of) messages.
</para>
<para>
This page instead goes deeper into the JBossWS WS-Security configuration details, covering more advanced topics.
</para>
<section id="WS_Security_options_Username_Token_Authentication"><title>Username Token Authentication</title>
<para>
The following configuration allows clients to authenticate through a Username Token (1). Thanks to the JAAS integration, the received token will automatically be verified against the configured JBoss JAAS Security Domain.<programlisting>&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.jboss.com/ws-security/config 
 http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
 &lt;config&gt;
(1) &lt;username/&gt;
(2) &lt;timestamp ttl="300"/&gt;
 &lt;/config&gt;
 &lt;/jboss-ws-security&gt;
</programlisting>Line (2) states that a timestamp element must be present in the message and that the message can not be older than 300 seconds; this is used to prevent replay attacks.
</para>
<para>
On the server side you should have:<programlisting>&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.jboss.com/ws-security/config
 http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;&lt;config&gt;&lt;timestamp ttl="300"/&gt;&lt;requires&gt;
(3)	 &lt;username/&gt;&lt;/requires&gt;&lt;/config&gt;&lt;/jboss-ws-security&gt;</programlisting>Line (3) sets the requirement of a Username Token for authentication.
</para>
<para>
Please note that this way username and password appear as simple text in the SOAP header. Thus it is strongly suggested to use a <link linkend="Secure_transport">secure transport</link>.
</para>

</section>
<section id="WS_Security_options_X509_Certificate_Token"><title>X509 Certificate Token</title>
<section id="WS_Security_options_Encryption"><title>Encryption</title>
<para>
Using X509v3 certificates you can both sign and encrypt messages. <programlisting>&lt;jboss-ws-security xmlns="http://www.jboss.com/ws-security/config"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://www.jboss.com/ws-security/config
 http://www.jboss.com/ws-security/schema/jboss-ws-security_1_0.xsd"&gt;
(1) &lt;key-store-file&gt;WEB-INF/bob-sign_enc.jks&lt;/key-store-file&gt;&lt;key-store-password&gt;password&lt;/key-store-password&gt;&lt;key-store-type&gt;jks&lt;/key-store-type&gt;&lt;trust-store-file&gt;WEB-INF/wsse10.truststore&lt;/trust-store-file&gt;&lt;trust-store-password&gt;password&lt;/trust-store-password&gt;&lt;config&gt;&lt;timestamp ttl="300"/&gt;
(2)	&lt;sign type="x509v3" alias="1" includeTimestamp="true"/&gt;
(3)	&lt;encrypt type="x509v3"
 alias="alice"
 algorithm="aes-256"
 keyWrapAlgorithm="rsa_oaep"
 tokenReference="keyIdentifier" /&gt;
(4) 	&lt;requires&gt;&lt;signature/&gt;&lt;encryption/&gt;&lt;/requires&gt;&lt;/config&gt;&lt;/jboss-ws-security&gt;</programlisting>The server configuration shown above includes:
</para>
<orderedlist numeration="arabic"><listitem>
<para>
Keystore and truststore information: location, password and type.
</para>
</listitem>
<listitem>
<para>
Signature configuration: you need to provide the certificate/key pair alias to use. <emphasis>includeTimestamp</emphasis> specifies whether the timestamp is to be signed too to prevent tampering.
</para>
</listitem>
<listitem>
<para>
Encryption configuration: you need to provide the certificate/key pair alias to use. 
</para>
</listitem>
<listitem>
<para>
Optional security requirements: incoming messages should be both signed and encrypted.
</para>
</listitem>
</orderedlist>
<para>
Client side configuration works the same way.
</para>
<section id="WS_Security_options_Algorithms"><title>Algorithms</title>
<para>
Asymmetric + symmetric encryption is performed whenever the <emphasis>encrypt</emphasis> element is found. Thus message data are encrypted using a generated symmetric secret key. This is written in the SOAP header after being encrypted (wrapped) with the receiver public key. You can set both the encryption and key wrap algorithms.
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Supported encryption algorithms
</para>
</listitem>
</itemizedlist>
<itemizedlist mark="opencircle"><listitem>
<para>
AES 128 (aes-128) (<emphasis>default</emphasis>)
</para>
</listitem>
<listitem>
<para>
AES 192 (aes-192)
</para>
</listitem>
<listitem>
<para>
AES 256 (aes-256)
</para>
</listitem>
<listitem>
<para>
Triple DES (triple-des)
</para>
</listitem>
</itemizedlist>
<itemizedlist mark="opencircle"><listitem>
<para>
Supported key wrap algorithms
</para>
</listitem>
</itemizedlist>
<itemizedlist mark="opencircle"><listitem>
<para>
RSA v.1.5 (rsa_15) (<emphasis>default</emphasis>)
</para>
</listitem>
<listitem>
<para>
RSA OAEP (rsa_oaep)
</para>
</listitem>
</itemizedlist>
<para>
The <ulink url="http://java.sun.com/javase/downloads/index_jdk5.jsp"><citetitle>Unlimited Strength Java(TM) Cryptography Extension</citetitle></ulink> installation might be required to run some strong algorithms (like AES-256). Please note that your country might have limits on allowed crypto strength.
</para>

</section>
<section id="WS_Security_options_Token_references"><title>Token references</title>
<para>
For interoperability reason you might want to configure the type of reference to encryption token to be used. For instance, Microsoft Indigo doesn't support direct reference to local binary security tokens that is the JBossWS default reference type choice.Allowed values for <emphasis>tokenReference</emphasis> attribute are:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
directReference (<emphasis>default</emphasis>)
</para>
</listitem>
<listitem>
<para>
keyIdentifier
</para>
</listitem>
<listitem>
<para>
x509IssuerSerial
</para>
</listitem>
</itemizedlist>
<para>
Please refer to the <ulink url="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-x509-token-profile-1.0.pdf"><citetitle>X.509 Token Profile 1.0</citetitle></ulink> specification for further details on token references.
</para>

</section>

</section>
<section id="WS_Security_options_Targets_configuration"><title>Targets configuration</title>
<para>
JBossWS gives you a fine grained control over the elements that have to be signed or encrypted.
</para>
<para>
This allows you to encrypt important data only (like credit card numbers) without waisting time on other information exchanged by the same service (email addresses, for example).To configure this, you just need to specify the QName of the SOAP elements to encrypt. The default behavior is to encrypt the whole SOAP body.<programlisting>&lt;encrypt type="x509v3" alias="alice"&gt;&lt;targets&gt;&lt;target type="qname"&gt;{http://www.my-company.com/cc}CardNumber&lt;/target&gt;&lt;target type="qname"&gt;{http://www.my-company.com/cc}CardExpiration&lt;/target&gt;&lt;target type="qname" contentOnly="true"&gt;{http://www.my-company.com/cc}CustomerData&lt;/target&gt;&lt;/targets&gt;&lt;/encrypt&gt;</programlisting>?The <emphasis>contentOnly</emphasis> attribute states whether the content of the element is to be encrypted as opposed to the entire element (default behavior). Target can be specified also for requirements upon message receipt.
</para>

</section>

</section>
<section id="WS_Security_options_Further_information"><title>Further information</title>
<itemizedlist mark="opencircle"><listitem>
<para>
The complete wsse configuration is specified in the <emphasis>src/main/resources/schema/jboss-ws-security_1_0.xsd</emphasis> schema that is available in the source code base.
</para>
</listitem>
<listitem>
<para>
The advanced examples described above are covered by the interoperability scenarios described here.
</para>
</listitem>
<listitem>
<para>
If you have doubts on the keystore/truststore content requirements for signing/encrypting messages, <ulink url="http://www.jboss.org/index.html?module=bb&amp;amp;op=viewtopic&amp;amp;t=94406"><citetitle>read here</citetitle></ulink>. Moreover you can find a text file in the sources showing the store configuration used for the interoperability tests (<emphasis>src/test/resources/interop/nov2007/wsse/shared/META-INF/readme.txt</emphasis>).
</para>
</listitem>
</itemizedlist>

</section>
</article><article id="FAQ">
<title>FAQ</title>
<para>
Category:Documentation (Category:Documentation)
</para>
<para>

</para>
<section id="FAQ_General"><title>General</title>
<section id="FAQ_Which_version_of_JBoss_Application_Server_do_I_need_to_use_JBossWS_3F"><title>Which version of JBoss Application Server do I need to use JBossWS?</title>
<para>
JBossWS integrates with most current JBoss Application Server releases as well as earlier ones, that did implement the J2EE 1.4 specifications. Event though JAX-RPC, the web service specification for J2EE 1.4, is still supported JBossWS does put a clear focus on JAX-WS.
</para>
<para>
Currently, JBossWS has integration layers for the JBossAS-5.0, JBossAS-4.2, JBossAS-4.0.5 and above; download and installation instructions are available on this WIKI.
</para>
<para>
Finally, if you need to use web services with previous AS releases, please refer to the <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossWSLegacyDocumentation"><citetitle>Legacy Documentation</citetitle></ulink>
</para>

</section>
<section id="FAQ_What_are_the_benefits_of_using_J2EE_web_services_3F"><title>What are the benefits of using J2EE web services?</title>
<para>
JBossWS ships both a J2EE-1.4 compliant and a JavaEE5 compliant web service stacks; the first one is based on the JSR-109 programming model, while the second one is based on the JAX-WS programming model.
</para>
<para>
Both stacks come with a great number of advantages for our users.
</para>
<para>
Here are a few:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Portable web service endpoints and clients that do not need to have a dependency on a proprietary stack
</para>
</listitem>
<listitem>
<para>
Secure your investment and learn a standard rather than a proprietary solution
</para>
</listitem>
<listitem>
<para>
Achieve good interoperability by beeing BasicProfile-1.1 compliant
</para>
</listitem>
<listitem>
<para>
Take advantage of test coverage that comes with Sun's Compatibility Test Suite (&gt;2300 WS tests)
</para>
</listitem>
<listitem>
<para>
Good integration with the overall JBoss architecture i.e. hot deployment/redeployment, management interface
</para>
</listitem>
</itemizedlist>
<para>
Our support offering covers our own stack and the JBossWS team is dedicated full time to improve that constantly.
</para>
<para>
However, starting from release 2.1.0, JBossWS will also provide an integration framework supporting other open source and specification compliant web service stacks, including Sun Metro and Apache CXF. Since each stack comes with its own specific functional feature set and performance characteristics users will be able to deploy the stack that best suits their needs. There will be a common deployment model and management interface to all deployable stacks.
</para>

</section>
<section id="FAQ_How_do_the_various_web_service_stacks_compare_3F"><title>How do the various web service stacks compare?</title>
<para>
JBossWSStackComparison
</para>

</section>
<section id="FAQ_What_version_of_the_specs_are_supported_3F"><title>What version of the specs are supported?</title>
<para>
JBossWSSpecStatus
</para>

</section>
<section id="FAQ_Where_is_the_authoritative_documentation_3F"><title>Where is the authoritative documentation?</title>
<para>
'''JavaEE5 compliant web services
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
<link linkend="User_Guide">JAX-WS User guide</link>
</para>
</listitem>
</itemizedlist>
<para>
'''J2EE-1.4 compliant web services
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
JAX-RPC User guide
</para>
</listitem>
</itemizedlist>

</section>
<section id="FAQ_Why_are_my_forum_posts_not_answered_more_quickly_3F"><title>Why are my forum posts not answered more quickly?</title>
<para>
Posts to the <ulink url="http://www.jboss.com/index.html?module=bb&amp;amp;op=viewforum&amp;amp;f=200"><citetitle>user forum</citetitle></ulink> will be dealt with at the community's leisure. If your business is such that you need to rely on <ulink url="http://www.jboss.com/services/profsupport"><citetitle>qualified answers within a known time frame</citetitle></ulink>, the forum might not be your preferred support channel.
</para>

</section>
<section id="FAQ_Are_there_any_samples_I_can_look_at_3F"><title>Are there any samples I can look at?</title>
<para>
Yes, samples are available from the JBossWS <ulink url="http://labs.jboss.com/jbossws/downloads"><citetitle>download page</citetitle></ulink>.
</para>

</section>
<section id="FAQ_Is_JAXWS_2C_JSR181_2C_EJB3_supported_3F"><title>Is JAXWS, JSR181, EJB3 supported?</title>
<para>
Yes, JAXWS, JSR181 and EJB3 are supported all together starting from JBossWS-1.2.0.GA. Please refer the JAX-WS user guide for further details and usage informations.
</para>
<para>
In JBossWS-1.0.x we provided a preview implementation for JSR-181 that worked for basic usecases, namely
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
rpc/literal, document/literal operations with primitive types
</para>
</listitem>
<listitem>
<para>
JAXRPC handlers using @HandlerChain
</para>
</listitem>
<listitem>
<para>
One way invocations
</para>
</listitem>
</itemizedlist>
<para>
JAXWS, which JSR181 is part of, delegates all marshalling concerns to JAXB. For this to work, complex beans must be annotated with JAXB annotations. Basically, the type mapping that was contained in JSR109 jaxrpc-mapping.xml is now in JAXB annotations.
</para>
<para>
With JBossWS-1.0.x all marshalling is done through JBossXB, which does not understand JAXB annotations.
</para>
<para>
Marshalling concerns that rely on JAXB functionality are not supported in JBossWS-1.0.x. In JBossWS-1.0.x JSR181 is provided as is and will not be extended.
</para>

</section>
<section id="FAQ_What_are_the_advantages_of_JAX_WS_over_JAX_RPC_3F"><title>What are the advantages of JAX-WS over JAX-RPC?</title>
<para>
JAX-WS_vs_JAX-RPC
</para>

</section>

</section>
<section id="FAQ_Installation"><title>Installation</title>
<section id="FAQ_How_do_I_install_JBossWS_on_jboss_4_0_x_non_EJB3_3F"><title>How do I install JBossWS on jboss-4.0.x non EJB3?</title>
<para>
Please refer to the installation guide.
</para>

</section>
<section id="FAQ_How_do_I_install_JBossWS_on_tomcat_3F"><title>How do I install JBossWS on tomcat?</title>
<para>
JBossWS came with a Tomcat porting layer up to release 1.2.1.GA. Recently this has been dropped because of too little community interest.
</para>
<para>
For installation instructions of old JBossWS releases on Tomcat please refer to the Legacy documentation.
</para>

</section>

</section>
<section id="FAQ_Development"><title>Development</title>
<section id="FAQ_What_do_I_do_if_I_think_there_is_a_bug_3F"><title>What do I do if I think there is a bug?</title>
<itemizedlist mark="opencircle"><listitem>
<para>
Check if it works with the latest sources.
</para>
</listitem>
<listitem>
<para>
Checkout the <ulink url="http://jira.jboss.com/jira/browse/JBWS?report=com.atlassian.jira.plugin.system.project:roadmap-panel"><citetitle>Road Map</citetitle></ulink> if you are using the latest release or the <ulink url="http://jira.jboss.com/jira/browse/JBWS?report=com.atlassian.jira.plugin.system.project:changelog-panel"><citetitle>Change Log</citetitle></ulink> if you are using another one.
</para>
</listitem>
<listitem>
<para>
Finally, if your bug hasn't been reported yet, please create a <ulink url="http://jira.jboss.com/jira/browse/JBWS?report=com.atlassian.jira.plugin.system.project:openissues-panel"><citetitle>JBossWS JIRA</citetitle></ulink> issue and attach a sample deployment that allows us to reproduce what you are seeing. Idealy, the sample deployment is a webapp packaged as a war that shows the issue when we click on a link. The war should also contain the sources.
</para>
</listitem>
</itemizedlist>

</section>
<section id="FAQ_Where_is_the_JBossWS_source_repository_3F"><title>Where is the JBossWS source repository?</title>
<para>
Please refer to Subversion.
</para>

</section>
<section id="FAQ_How_can_I_build_and_install_the_latest_3F"><title>How can I build and install the latest?</title>
<para>
Please refer to the development guide: Building_From_Source
</para>

</section>

</section>
<section id="FAQ_Server"><title>Server</title>
<para>
see al
</para>
<section id="FAQ_How_does_rewriting_of_the_soap_address_in_WSDL_work_3F"><title>How does rewriting of the soap address in WSDL work?</title>
<para>
Have a look at jbossws.sar/jbossws.beans/META-INF/jboss-beans.xml
</para>
<para>
<programlisting>&lt;bean name="WSServerConfig" class="org.jboss.wsf.spi.management.BasicServerConfig"&gt;&lt;property name="webServiceHost"&gt;${jboss.bind.address}&lt;/property&gt;&lt;property name="modifySOAPAddress"&gt;true&lt;/property&gt;&lt;/bean&gt;</programlisting>
</para>
<para>
If instead of a folder <emphasis>jbossws.sar/jbossws.beans</emphasis> you have a file you will need to extract the <emphasis>jbossws.beans</emphasis> (It is just a normal archive) and convert it into an exploded deployment.
</para>
<para>
Instead of hardcoding the correct &lt;soap:address&gt; in the WSDL on the client side, you can use jboss-client.xml to point to the server side generated WSDL
</para>
<para>
<programlisting>&lt;jboss-client&gt;&lt;jndi-name&gt;jbossws-client&lt;/jndi-name&gt;&lt;service-ref&gt;&lt;service-ref-name&gt;service/MyService&lt;/service-ref-name&gt;&lt;wsdl-override&gt;http://@jboss.bind.address@:8080/jaxws-test/MyService?wsdl&lt;/wsdl-override&gt;&lt;/service-ref&gt;&lt;/jboss-client&gt;</programlisting>
</para>
<para>
This of course has the disadvantage that the client has to do an HTTP GET when the Service is constructed.
</para>

</section>
<section id="FAQ_How_do_I_know_what_endpoint_address_is_being_used_3F"><title>How do I know what endpoint address is being used?</title>
<para>
<emphasis role="bold">The endpoint context root is computed as follows</emphasis>
</para>
<para>
1.) Use the explicit context root from the web meta data
</para>
<para>
Can be set in jboss-web.xml and is only relevant for JSE endpoints.
</para>
<para>
2.) Use the explicit context root from @WebContext.contextRoot
</para>
<para>
Can only be set on EJB endpoints.
</para>
<para>
3.) Use the explicit context root from webservices/context-root
</para>
<para>
Can be set in jboss.xml and is only relevant for EJB endpoints.
</para>
<para>
4.) Use the explicit context root from port-component/port-component-uri
</para>
<para>
For backward compatibility, this uses the first token from port-component-uri in jboss.xml.It is only relevant for legacy EJB endpoints and should not be used. 
</para>
<para>
5.) Use the implicit context root derived from the deployment name
</para>
<para>
If the context root is not explicitly set we fall back to the simple deployment name for both JSE and EJB endpoints. If the endpoint is deployed as part of an EAR, the context root is prepended by simple EAR name.
</para>
<para>
<emphasis role="bold">The URL pattern is computed as follows</emphasis>
</para>
<para>
1) Use the explicit url-pattern from the servlet mappings 
</para>
<para>
Must be set in web.xml and is only relevant for JSE endpoints.
</para>
<para>
2) Use the explicit url-pattern from port-component/port-component-uri
</para>
<para>
Can be set in jboss.xml and is only relevant for EJB endpoints.
</para>
<para>
3) Use the explicit url-pattern from @WebContext.urlPattern 
</para>
<para>
Can only be set on EJB endpoints.
</para>
<para>
4) Use the implicit url-pattern from ejb-name <programlisting/>
</para>
<para>
If the url-pattern for an EJB endpoint is not explicitly set, we fall back to the ejb-name.
</para>
<para>
<emphasis role="bold">Examples</emphasis>
</para>
<para>
<programlisting>
@Stateless
@WebService
@WebContext( contextRoot = "/webservices" )
@Remote( UserService.class )
public class ExampleServiceBean implements ExampleService {
 ...
}
</programlisting>
</para>
<para>
Will bind to http://localhost:8080/webservices/ExampleServiceBean
</para>
<para>
<programlisting>
@Stateless
@WebService
@WebContext( contextRoot = "/webservices" , urlPattern="/ExampleService" )
@Remote( UserService.class )
public class ExampleServiceBean implements ExampleService {
 ...
}
</programlisting>
</para>
<para>
Will bind to http://localhost:8080/webservices/ExampleService
</para>
<para>
The default behavior in jboss 4.0.5 was to use the jar file name followed by the ejb name. This can be replicated by using the WebContext annotation e.g.
</para>
<para>
<programlisting>
@WebService
@WebContext( contextRoot = "/jar-file-name" , urlPattern="/ejb-name" )
</programlisting>
</para>

</section>
<section id="FAQ_What_are_the_advantages_and_disadvantages_of_using_Tomcat_embedded_3F"><title>What are the advantages and disadvantages of using Tomcat embedded?</title>
<para>
What are the advantages and disadvantages of using Tomcat embedded inside of JBoss Application Server versus running Tomcat independently?
</para>
<para>
If you are using advanced J2EE features (JMS, JAAS, EJB, etc.), then you need a complete J2EE application server (JBoss AS) and one question to consider is whether you need to separate the JSP/Servlet tier from the application server. In this scenario, you should consider using Apache Tomcat inside of JBoss AS for significant performance improvements (ex. JSPs can call EJBs via pass-by-reference), unless your architecture or corporate security policies dictate otherwise.
</para>
<para>
If you are using Tomcat for basic JSPs and servlets then read below.
</para>
<para>
Advantages of Tomcat inside JBoss AS :
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Easily grow and enhance your applications when other J2EE requirements arise (EJB, JMS, JAAS, etc.)
</para>
</listitem>
<listitem>
<para>
JDBC connection pooling
</para>
</listitem>
<listitem>
<para>
Advanced clustering
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Simple method of deploying/undeploying applications to entire cluster (farm deployment)
</para>
</listitem>
<listitem>
<para>
Improved performance through <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=HttpSession"><citetitle>HttpSession</citetitle></ulink> replication via <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossCache"><citetitle>JBossCache</citetitle></ulink>
</para>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<para>
Simplified Hot Deployment &amp; Hot Redeployment
</para>
</listitem>
<listitem>
<para>
<ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossAOP"><citetitle>AOP</citetitle></ulink> enablement of JSPs &amp; Servlets
</para>
</listitem>
<listitem>
<para>
Ability to easily upgrade to using J2EE services such as JMS, JTA, JNDI, etc.
</para>
</listitem>
<listitem>
<para>
Ability to centrally manage and monitor Tomcat with other JBoss services
</para>
</listitem>
<listitem>
<para>
Write access to JNDI at runtime (Tomcat's is read-only at runtime)
</para>
</listitem>
</itemizedlist>
<para>
If you run the JBoss AS 4.0.3 (or higher) installer at http://labs.jboss.com/jbossas/downloads, you can choose from a variety of install profiles including a profile that installs Tomcat along with additional JMX JTA, JNDI, Security, and deployment services pre-configured.
</para>
<para>
Advantages of Tomcat Standalone:
</para>
<itemizedlist mark="opencircle"><listitem>
<para>
Maybe simplicity of administration? (although this may be of little value because JBoss allows you to strip down the application server so there is little else running)
</para>
</listitem>
<listitem>
<para>
Defaults to isolated classloading for WARs (however, there is a simple configuration in JBoss AS called <ulink url="http://wiki.jboss.org/wiki/Wiki.jsp?page=UseJBossWebLoader"><citetitle>"UseJBossWebLoader"</citetitle></ulink> which does the same thing)
</para>
</listitem>
</itemizedlist>

</section>
<section id="FAQ_How_to_use_JDK_JMX_JConsole_with_JBossWS_3F"><title>How to use JDK JMX JConsole with JBossWS?</title>
<para>
You must use JDK 5 or above on JBoss server sidewith the following JVM properties set on the commandline:
</para>
<para>
<programlisting>
JAVA_OPTS="$JAVA_OPTS -Djavax.management.builder.initial=org.jboss.system.server.jmx.MBeanServerBuilderImpl"
JAVA_OPTS="$JAVA_OPTS -Djboss.platform.mbeanserver"
JAVA_OPTS="$JAVA_OPTS -Dcom.sun.management.jmxremote"</programlisting>
</para>
<para>
Running the jconsole against this configuration will bring up a console that incorporates both the JBoss and JVM MBeans.
</para>
<para>
For further information follow this link: http://wiki.jboss.org/wiki/Wiki.jsp?page=JBossMBeansInJConsole
</para>
<para>
For JMX information in JBoss AS in general follow this link: http://wiki.jboss.org/wiki/Wiki.jsp?page=FAQJBossJMX
</para>

</section>
<section id="FAQ_Why_I_27m_getting_"><title>Why I'm getting "propertyname is not valid property on class mypackage.jaxws.Propertyname"?</title>
<para>
If you are getting the following exception:
</para>
<para>
<programlisting>
org.jboss.ws.WSException: propertyname is not a valid property on class mypackage.jaxws.Propertyname
 at com.sun.xml.bind.v2.runtime.JAXBContextImpl.getElementPropertyAccessor(JAXBContextImpl.java)
 at org.jboss.ws.metadata.acessor.JAXBAccessor$1$1.create(JAXBAccessor.java)
</programlisting>
</para>
<para>
then you are facing the JAX-WS defaults problem. JAX-WS specification gives these requirements on Document Wrapped:
</para>
<para>
<programlisting>
From JAX-WS 2.0 19. April 2006:

3.6.2.1 Document Wrapped:

* Conformance (Default wrapper bean names): In the absence of customizations, the wrapper request bean
 class MUST be named the same as the method and the wrapper response bean class MUST be named the
 same as the method with a "Response" suffix. The first letter of each bean name is capitalized to follow
 Java class naming conventions.
* Conformance (Default wrapper bean package): In the absence of customizations,
 the wrapper beans package UST be a generated jaxws subpackage of the SEI package.
* Conformance (Wrapper bean name clash): Generated bean classes must have unique names within a pack-
 age and MUST NOT clash with other classes in that package. Clashes during generation MUST be reported
 as an error and require user intervention via name customization to correct. Note that some platforms 
 do not distiguish filenames based on case so comparisons MUST ignore case.
</programlisting>
</para>
<para>
That means when you are using JBossWS with Document Wrapped you can't have two methods with same nameinside the package without specifying customizations. Thus to solve your problem you have to specify at least:
</para>
<para>
<programlisting>
 @javax.xml.ws.RequestWrapper(className="package.UniqueClassName")
 @javax.xml.ws.ResponseWrapper(className="package.UniqueClassNameResponse") 
</programlisting>
</para>
<para>
method annotations on all overloaded methods (overloaded here means notoverloaded in class but overloaded in package).
</para>

</section>
<section id="FAQ_How_can_I_access_the_HttpServletRequest_and_HttpServletResponse_from_my_endpoint_3F"><title>How can I access the HttpServletRequest and HttpServletResponse from my endpoint?</title>

</section>

</section>
<section id="FAQ_Client"><title>Client</title>
<section id="FAQ_How_do_I_generate_the_required_artifacts_3F"><title>How do I generate the required artifacts?</title>
<para>
JBossWS ships with a set of tools to generate the required JAX-WS artefacts to build client implementations. The <link linkend="Wsconsume">wsconsume tool</link> is used to consume the abstract contract (WSDL) and produce annotated Java classes (and optionally sources) that define it. You can run wsconsume from the command line and from an <ulink url="http://ant.apache.org"><citetitle>Apache Ant</citetitle></ulink> target.
</para>
<para>
To run wsconsume from the command line, use the scripts available in the <emphasis>bin</emphasis> dir of your JBoss AS installation.
</para>
<para>
Here is an example of how to run wsconsume from the command line, generating source and class files in the org.foo package, in a custom directory.
</para>
<para>
<programlisting>wsconsume -k -o custom -p org.foo Example.wsdl</programlisting>
</para>
<para>
For further informations and examples, also check the <link linkend="JBossWS_JAX_WS_Tools_Top_Down__28Using_wsconsume_29">top-down development strategy</link> in the user guide.
</para>
<para>
Finally, if you need JAX-RPC artifacts generation, please refer to the legacy JBossWS tools documentation.
</para>

</section>
<section id="FAQ_How_can_I_leverage_the_client_deployment_model_3F"><title>How can I leverage the client deployment model?</title>
<para>
The WS client deployment model has many advantages over DII. Most Java applications (except the most trivial ones) have a need for registry lookup (JNDI) and management (JMX). A very minimal jboss configuration has a tiny footprint and provides just that. Therefore, you might want to consider running your client app on jboss and manage it through jmx-console and have a layer of indirection for resource lookup through JNDI. Additionally, you could then use the WS client programming model and obtain preconfigured WS clients form JNDI.
</para>

</section>
<section id="FAQ_How_can_I_setup_my_client_to_use_a_proxy_3F"><title>How can I setup my client to use a proxy?</title>
<para>
http://labs.jboss.com/jbossremoting/docs/guide/ch05.html 5.4.10. HTTP(S) Client Invoker - proxy and basic authentication
</para>

</section>
<section id="FAQ_What_client_artifacts_are_thread_safe_3F"><title>What client artifacts are thread safe?</title>
<para>
javax.xml.rpc.ServiceFactory - Just a factory so yes it is thread safe.
</para>
<para>
javax.xml.rpc.Service - A factory for calls and stubs so it is thread safe.
</para>
<para>
javax.xml.rpc.Call - Not thread safe, the API allows for multiple method invocations for a single WS call.
</para>
<para>
javax.xml.rpc.Stub - Contains properties that may be thread specific. Stub is the interface implemented by the dynamic proxy which delegatesto an implementation of Call. So, whatever is true for Call also holds for the dynamic proxy implementing Stub.
</para>

</section>
<section id="FAQ_What_client_jars_do_I_need_3F"><title>What client jars do I need?</title>
<para>
Have a look at <link linkend="Wsrunclient">wsrunclient.sh</link>.
</para>

</section>
<section id="FAQ_What_XML_parser_do_I_need_3F"><title>What XML parser do I need?</title>
<para>
You should use xerces.<programlisting>  -Djava.endorsed.dirs=$JBOSS_HOME/lib/endorsed</programlisting>
</para>

</section>

</section>
<section id="FAQ_Tools"><title>Tools</title>
<section id="FAQ_Why_do_I_get_a_NullPointerException_when_using_wstools_3F"><title>Why do I get a NullPointerException when using wstools?</title>
<para>
<programlisting>
[wstools] java.lang.NullPointerException
[wstools] at java.lang.System.arraycopy(Native Method)
[wstools] at org.apache.xerces.impl.xs.XSModelImpl.getAnnotations(Unknown Source)
[wstools] at org.jboss.ws.metadata.wsdl.xmlschema.WSSchemaUtils.copyXSModel(WSSchemaUtils.java:737)
[wstools] at org.jboss.ws.tools.JavaToXSD.parseSchema(JavaToXSD.java:201)
[wstools] at org.jboss.ws.metadata.wsdl.WSDL11Reader.processTypes(WSDL11Reader.java:227)
[wstools] at org.jboss.ws.metadata.wsdl.WSDL11Reader.processDefinition(WSDL11Reader.java:118)
[wstools] at org.jboss.ws.metadata.wsdl.WSDLDefinitionsFactory.parse(WSDLDefinitionsFactory.java:145)
[wstools] at org.jboss.ws.tools.WSDLToJava.convertWSDL2Java(WSDLToJava.java:121)
[wstools] at org.jboss.ws.tools.helpers.ToolsHelper.handleWSDLToJavaGeneration(ToolsHelper.java:323)
[wstools] at org.jboss.ws.tools.WSTools.process(WSTools.java:138)
[wstools] at org.jboss.ws.tools.WSTools.generate(WSTools.java:120)
[wstools] at org.jboss.ws.tools.ant.wstools.execute(wstools.java:103)
 ...
</programlisting>
</para>
<para>
This is a xerces bug that was fixed in 2.7.0. Unfortunately, the latest version of ant comes with 2.6.2. You need to update the xerces jars in your ANT_HOME/lib directory to be at least 2.7.0.
</para>

</section>
<section id="FAQ_How_can_I_configure_RPC_parameter_names_3F"><title>How can I configure RPC parameter names?</title>
<para>
Parameter and result names can be configured using the JSR-181 <link linkend="JAX_WS_Annotations_javax_jws_WebParam">@WebParam</link> and <link linkend="JAX_WS_Annotations_javax_jws_WebResult">@WebResult</link> annotations:<programlisting>
@WebMethod(operationName = "SecurePing")
@WebResult(name = "Result")
public String ping(
 @WebParam(name = "Ping") PingDocument p, 
 @WebParam(name = "SecHeader", header = true) SecurityHeader secHdr)
{
 log.info("ping: " + p + "," + secHdr);
 return "pong";
}
</programlisting>
</para>

</section>
<section id="FAQ_Customizing_WSDL_Schema_Generation"><title>Customizing WSDL Schema Generation</title>
<para>

</para>
<para>
Both <emphasis role="bold">JBossWS runtime</emphasis> and <emphasis role="bold">WSProvide tool</emphasis> use <emphasis role="bold">JAXB</emphasis> (concretely <emphasis role="bold">JAXBRIContext.generateSchema()</emphasis> method) for WSDL schema generation thus the onlypossible way of schema customization is through <emphasis role="bold">javax.xml.bind.annotation.*</emphasis>annotations.
</para>
<para>
<programlisting>  Therefore users that want to customize WSDL schema generation process should</programlisting>
</para>
<para>
be familiar with these annotations. We suggest everyone interested in to takea look to <emphasis role="bold">Java Types To XML</emphasis> chapter of <emphasis role="bold">JAXB specification</emphasis>.
</para>
<para>
In the case user want to customize the generated WSDL schema and he is not able to achievethat through <emphasis role="bold">javax.xml.bind.annotation.*</emphasis> annotations he have always the possibilityto customize the generated WSDL contract and force <emphasis role="bold">JBossWS runtime</emphasis> to use it via<emphasis role="bold">javax.jws.WebService.wsdlLocation</emphasis> annotation field.
</para>
</section>

</section>
</article><article id="JAX_WS_Annotations">
<title>JAX-WS Annotations</title>
<para>
Category:Development (Category:Development)
</para>
<section id="JAX_WS_Annotations_JAX_WS_Annotations"><title>JAX-WS Annotations</title>
<para>
For details, see <ulink url="http://www.jcp.org/en/jsr/detail?id=224"><citetitle>JSR-224 - Java API for XML-Based Web Services (JAX-WS) 2.0</citetitle></ulink>
</para>
<section id="JAX_WS_Annotations_javax_xml_ws_ServiceMode"><title>javax.xml.ws.ServiceMode</title>
<para>
The ServiceMode annotation is used to specify the mode for a provider class, i.e. whether a provider wantsto have access to protocol message payloads (e.g. a SOAP body) or the entire protocol messages (e.g. aSOAP envelope).
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_WebFault"><title>javax.xml.ws.WebFault</title>
<para>
The WebFault annotation is used when mappingWSDL faults to Java exceptions, see section 2.5. It is usedto capture the name of the fault element used when marshalling the JAXB type generated from the globalelement referenced by the WSDL fault message. It can also be used to customize the mapping of servicespecific exceptions to WSDL faults.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_RequestWrapper"><title>javax.xml.ws.RequestWrapper</title>
<para>
The RequestWrapper annotation is applied to the methods of an SEI. It is used to capture the JAXB generatedrequest wrapper bean and the element name and namespace for marshalling / unmarshalling the bean.The default value of localName element is the operationName as defined in WebMethod annotation andthe default value for the targetNamespace element is the target namespace of the SEI.When starting fromJava, this annotation is used to resolve overloading conflicts in document literal mode. Only the classNameelement is required in this case.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_ResponseWrapper"><title>javax.xml.ws.ResponseWrapper</title>
<para>
The ResponseWrapper annotation is applied to the methods of an SEI. It is used to capture the JAXBgenerated response wrapper bean and the element name and namespace for marshalling / unmarshalling thebean. The default value of the localName element is the operationName as defined in the WebMethodappended with ?Response? and the default value of the targetNamespace element is the target namespaceof the SEI. When starting from Java, this annotation is used to resolve overloading conflicts in documentliteral mode. Only the className element is required in this case.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_WebServiceClient"><title>javax.xml.ws.WebServiceClient</title>
<para>
The WebServiceClient annotation is specified on a generated service class (see 2.7). It is used to associatea class with a specific Web service, identify by a URL to a WSDL document and the qualified nameof a wsdl:service element.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_WebEndpoint"><title>javax.xml.ws.WebEndpoint</title>
<para>
The WebEndpoint annotation is specified on the getPortName() methods of a generated service class(see 2.7). It is used to associate a get method with a specific wsdl:port, identified by its local name (aNCName).
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_WebServiceProvider"><title>javax.xml.ws.WebServiceProvider</title>
<para>
The WebServiceProvider annotation is specified on classes that implement a strongly typed javax-.xml.ws.Provider. It is used to declare that a class that satisfies the requirements for a provider (see5.1) does indeed define a Web service endpoint, much like the WebService annotation does for SEI-basedendpoints.
</para>
<para>
The WebServiceProvider and WebService annotations are mutually exclusive.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_BindingType"><title>javax.xml.ws.BindingType</title>
<para>
The BindingType annotation is applied to an endpoint implementation class. It specifies the binding touse when publishing an endpoint of this type.
</para>
<para>
The default binding for an endpoint is the SOAP 1.1/HTTP one
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_WebServiceRef"><title>javax.xml.ws.WebServiceRef</title>
<para>
The WebServiceRef annotation is used to declare a reference to a Web service. It follows the resourcepattern exemplified by the javax.annotation.Resource annotation in JSR-250 [32].The WebServiceRef annotation is required to be honored when running on the Java EE 5 platform, whereit is subject to the common resource injection rules described by the platform specification [33].
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_WebServiceRefs"><title>javax.xml.ws.WebServiceRefs</title>
<para>
The WebServiceRefs annotation is used to declare multiple references to Web services on a single class.It is necessary to work around the limition against specifying repeated annotations of the same type onany given class, which prevents listing multiple javax.ws.WebServiceRef annotations one after theother. This annotation follows the resource pattern exemplified by the javax.annotation.Resourcesannotation in JSR-250.
</para>
<para>
Since no name and type can be inferred in this case, each WebServiceRef annotation inside a WebServiceRefsMUST contain name and type elements with non-default values.The WebServiceRef annotation is required to be honored when running on the Java EE 5 platform, whereit is subject to the common resource injection rules described by the platform specification.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_Action"><title>javax.xml.ws.Action</title>
<para>
The Action annotation is applied to themethods of a SEI. It used to generate the wsa:Action on wsdl:inputand wsdl:output of each wsdl:operation mapped from the annotated methods.
</para>

</section>
<section id="JAX_WS_Annotations_javax_xml_ws_FaultAction"><title>javax.xml.ws.FaultAction</title>
<para>
The FaultAction annotation is used within the Action annotation to generate the wsa:Action elementon the wsdl:fault element of each wsdl:operation mapped from the annotated methods.
</para>

</section>
<section id="JAX_WS_Annotations_Annotations_Defined_by_JSR_181"><title>Annotations Defined by JSR-181</title>
<para>
JSR-181 defines the syntax and semantics of Java Web Service (JWS) metadata and default values. 
</para>
<para>
For details, see <ulink url="http://jcp.org/en/jsr/detail?id=181"><citetitle>JSR 181 - Web Services Metadata for the Java Platform</citetitle></ulink>
</para>
<section id="JAX_WS_Annotations_javax_jws_WebService"><title>javax.jws.WebService</title>
<para>
Marks a Java class as implementing a Web Service, or a Java interface as defining a Web Service interface.
</para>

</section>
<section id="JAX_WS_Annotations_javax_jws_WebMethod"><title>javax.jws.WebMethod</title>
<para>
Customizes a method that is exposed as a Web Service operation.
</para>

</section>
<section id="JAX_WS_Annotations_javax_jws_OneWay"><title>javax.jws.OneWay</title>
<para>
Indicates that the given web method has only an input message and no output. Typically, a oneway method returns the thread of control to the calling application prior to executing the actual business method. A JSR-181 processor is REQUIRED to report an error if an operation marked @Oneway has a return value, declares any checked exceptions or has any INOUT or OUT parameters.
</para>

</section>
<section id="JAX_WS_Annotations_javax_jws_WebParam"><title>javax.jws.WebParam</title>
<para>
Customizes the mapping of an individual parameter to a Web Service message part andXML element.
</para>

</section>
<section id="JAX_WS_Annotations_javax_jws_WebResult"><title>javax.jws.WebResult</title>
<para>
Customizes the mapping of the return value to a WSDL part and XML element.
</para>

</section>
<section id="JAX_WS_Annotations_javax_jws_SOAPBinding"><title>javax.jws.SOAPBinding</title>
<para>
Specifies the mapping of the Web Service onto the SOAP message protocol. 
</para>
<para>
The SOAPBinding annotation has a target of TYPE and METHOD. The annotation may be placed on a method if and only if the SOAPBinding.style is DOCUMENT. Implementations MUST report an error if the SOAPBinding annotation is placed on a method with a SOAPBinding.style of RPC. Methods that do not have a SOAPBinding annotation accept the SOAPBinding behavior defined on the type.
</para>

</section>
<section id="JAX_WS_Annotations_javax_jws_HandlerChain"><title>javax.jws.HandlerChain</title>
<para>
The @HandlerChain annotation associates the Web Service with an externally defined handler chain. 
</para>
<para>
It is an error to combine this annotation with the @SOAPMessageHandlers annotation. 
</para>
<para>
The @HandlerChain annotation MAY be present on the endpoint interface and service implementation bean. The service implementation bean?s @HandlerChain is used if @HandlerChain is present on both.
</para>
<para>
The @HandlerChain annotation MAY be specified on the type only. The annotation target includes METHOD and FIELD for use by JAX-WS-2.0.
</para>
</section>

</section>

</section>
</article><article id="Wsconsume">
<title>Wsconsume</title>
<para>
wsconsume is a command line tool and ant task that "consumes" the abstract contract (WSDL file) and produces portable JAX-WS service and client artifacts. For a more detailed overview, see <link linkend="JBossWS_JAX_WS_Tools_Top_Down__28Using_wsconsume_29">"Using wsconsume"</link>.
</para>
<section id="Wsconsume_Command_Line_Tool"><title>Command Line Tool</title>
<para>
The command line tool has the following usage:<programlisting>
usage: wsconsume [options] &lt;wsdl-url&gt;
options: 
 -h, --help Show this help message
 -b, --binding=&lt;file&gt; One or more JAX-WS or JAXB binding files
 -k, --keep Keep/Generate Java source
 -c --catalog=&lt;file&gt; Oasis XML Catalog file for entity resolution
 -p --package=&lt;name&gt; The target package for generated source
 -w --wsdlLocation=&lt;loc&gt; Value to use for @WebService.wsdlLocation
 -o, --output=&lt;directory&gt; The directory to put generated artifacts
 -s, --source=&lt;directory&gt; The directory to put Java source
 -q, --quiet Be somewhat more quiet
 -t, --show-traces Show full exception stack traces
</programlisting>
</para>
<section id="Wsconsume_Examples"><title>Examples</title>
<para>
Generate artifacts in Java class form only:<programlisting>
wsconsume Example.wsdl
</programlisting>
</para>
<para>
Generate source and class files:<programlisting>
wsconsume -k Example.wsdl
</programlisting>
</para>
<para>
Generate source and class files in a custom directory:<programlisting>
wsconsume -k -o custom Example.wsdl
</programlisting>
</para>
<para>
Generate source and class files in the org.foo package:<programlisting>
wsconsume -k -p org.foo Example.wsdl
</programlisting>
</para>
<para>
Generate source and class files using multiple binding files:<programlisting>
wsconsume -k -b wsdl-binding.xml -b schema1-binding.xml -b schema2-binding.xml
</programlisting>
</para>

</section>

</section>
<section id="Wsconsume_Ant_Task"><title>Ant Task</title>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
With 2.0.GA the task was renamed to org.jboss.wsf.spi.tools.ant.WSConsumeTask
</para>
<para>
The wsconsume ant task has the following attributes:<table>
<title/><tgroup cols="3"><tbody><row>
<entry>
Attribute
</entry>
<entry>
Description
</entry>
<entry>
Default
</entry>

</row>
<row>
<entry>
fork
</entry>
<entry>
Whether or not to run the generation task in a separate VM.
</entry>
<entry>
true
</entry>

</row>
<row>
<entry>
keep
</entry>
<entry>
Keep/Enable Java source code generation.
</entry>
<entry>
false
</entry>

</row>
<row>
<entry>
catalog
</entry>
<entry>
Oasis XML Catalog file for entity resolution
</entry>
<entry>
none
</entry>

</row>
<row>
<entry>
package
</entry>
<entry>
The target Java package for generated code.
</entry>
<entry>
generated
</entry>

</row>
<row>
<entry>
binding
</entry>
<entry>
A JAX-WS or JAXB binding file
</entry>
<entry>
none
</entry>

</row>
<row>
<entry>
wsdlLocation
</entry>
<entry>
Value to use for @WebService.wsdlLocation
</entry>
<entry>
generated
</entry>

</row>
<row>
<entry>
destdir
</entry>
<entry>
The output directory for generated artifacts.
</entry>
<entry>
"output"
</entry>

</row>
<row>
<entry>
sourcedestdir
</entry>
<entry>
The output directory for Java source.
</entry>
<entry>
value of destdir
</entry>

</row>
<row>
<entry>
verbose
</entry>
<entry>
Enables more informational output about command progress.
</entry>
<entry>
false
</entry>

</row>
<row>
<entry>
wsdl
</entry>
<entry>
The WSDL file or URL
</entry>
<entry>
n/a
</entry>

</row>
</tbody></tgroup>
</table>

</para>
<para>
Also, the following nested elements are supported:<table>
<title/><tgroup cols="3"><tbody><row>
<entry>
Element
</entry>
<entry>
Description
</entry>
<entry>
Default
</entry>

</row>
<row>
<entry>
binding
</entry>
<entry>
A JAX-WS or JAXB binding file
</entry>
<entry>
none
</entry>

</row>
<row>
<entry>
jvmarg
</entry>
<entry>
Allows setting of custom jvm arguments
</entry>

</row>
</tbody></tgroup>
</table>

</para>
<section id="Wsconsume_Examples_2"><title>Examples</title>
<para>
Generate JAX-WS source and classes in a separate JVM with separate directories, a custom wsdl location attribute, and a list of binding files from foo.wsdl:<programlisting>&lt;wsconsume 
 fork="true"
 verbose="true"
 destdir="output"
 sourcedestdir="gen-src"
 keep="true"
 wsdllocation="handEdited.wsdl" 
 wsdl="foo.wsdl"&gt;
 &lt;binding dir="binding-files" includes="*.xml" excludes="bad.xml"/&gt;
&lt;/wsconsume&gt;
</programlisting>
</para>

</section>

</section>
<section id="Wsconsume_Related_information"><title>Related information</title>
<itemizedlist mark="opencircle"><listitem>
<para>
<ulink url="http://java.sun.com/webservices/docs/2.0/jaxws/customizations.html"><citetitle>JAX-WS binding customization</citetitle></ulink>
</para>
</listitem>
</itemizedlist>
<para>
Category:Tools (Category:Tools)
</para>
</section>
</article><article id="Wsprovide">
<title>Wsprovide</title>
<para>
wsprovide is a command line tool and ant task that generates portable JAX-WS artifactsfor a service endpoint implementation. It also has the option to "provide" the abstract contract for offline usage. See <link linkend="JBossWS_JAX_WS_Tools_Bottom_Up__28Using_wsprovide_29">"Using wsprovide"</link> for a detailed walk-through.
</para>
<section id="Wsprovide_Command_Line_Tool"><title>Command Line Tool</title>
<para>
The command line tool has the following usage:<programlisting>
 usage: wsprovide [options] &lt;endpoint class name&gt;
 options: 
 -h, --help Show this help message
 -k, --keep Keep/Generate Java source
 -w, --wsdl Enable WSDL file generation
 -c. --classpath=&lt;path&lt; The classpath that contains the endpoint
 -o, --output=&lt;directory&gt; The directory to put generated artifacts
 -r, --resource=&lt;directory&gt; The directory to put resource artifacts
 -s, --source=&lt;directory&gt; The directory to put Java source
 -q, --quiet Be somewhat more quiet
 -t, --show-traces Show full exception stack traces
</programlisting>
</para>
<section id="Wsprovide_Examples"><title>Examples</title>
<para>
Generating wrapper classes for portable artifacts in the "generated" directory:<programlisting>
wsprovide -o generated foo.Endpoint
</programlisting>
</para>
<para>
Generating wrapper classes and WSDL in the "generated" directory<programlisting>
wsprovide -o generated -w foo.Endpoint
</programlisting>
</para>
<para>
Using an endpoint that references other jars<programlisting>
wsprovide -o generated -c application1.jar:application2.jar foo.Endpoint
</programlisting>
</para>

</section>

</section>
<section id="Wsprovide_Ant_Task"><title>Ant Task</title>
<para>
<emphasis role="bold">Note</emphasis>
</para>
<para>
With 2.0.GA the task was renamed to org.jboss.wsf.spi.tools.ant.WSProvideTask
</para>
<para>
The wsprovide ant task has the following attributes:<table>
<title/><tgroup cols="3"><tbody><row>
<entry>
Attribute
</entry>
<entry>
Description
</entry>
<entry>
Default
</entry>

</row>
<row>
<entry>
fork
</entry>
<entry>
Whether or not to run the generation task in a separate VM.
</entry>
<entry>
true
</entry>

</row>
<row>
<entry>
keep
</entry>
<entry>
Keep/Enable Java source code generation.
</entry>
<entry>
false
</entry>

</row>
<row>
<entry>
destdir
</entry>
<entry>
The output directory for generated artifacts.
</entry>
<entry>
"output"
</entry>

</row>
<row>
<entry>
resourcedestdir
</entry>
<entry>
The output directory for resource artifacts (WSDL/XSD).
</entry>
<entry>
value of destdir
</entry>

</row>
<row>
<entry>
sourcedestdir
</entry>
<entry>
The output directory for Java source.
</entry>
<entry>
value of destdir
</entry>

</row>
<row>
<entry>
genwsdl
</entry>
<entry>
Whether or not to generate WSDL.
</entry>
<entry>
false
</entry>

</row>
<row>
<entry>
verbose
</entry>
<entry>
Enables more informational output about command progress.
</entry>
<entry>
false
</entry>

</row>
<row>
<entry>
<emphasis role="bold">sei</emphasis>
</entry>
<entry>
<emphasis role="bold">Service Endpoint Implementation.</emphasis>
</entry>

</row>
<row>
<entry>
classpath
</entry>
<entry>
The classpath that contains the service endpoint implementation.
</entry>
<entry>
"."
</entry>

</row>
</tbody></tgroup>
</table>

</para>
<section id="Wsprovide_Examples_2"><title>Examples</title>
<para>
Executing wsprovide in verbose mode with separate output directories for source, resources, and classes:<programlisting>&lt;target name="test-wsproivde" depends="init"&gt;
 &lt;taskdef name="wsprovide" classname="org.jboss.wsf.spi.tools.ant.WSProvideTask"&gt;
 &lt;classpath refid="core.classpath"/&gt;
 &lt;/taskdef&gt;
 &lt;wsprovide
 fork="false"
 keep="true"
 destdir="out"
 resourcedestdir="out-resource"
 sourcedestdir="out-source"
 genwsdl="true" 
 verbose="true"
 sei="org.jboss.test.ws.jaxws.jsr181.soapbinding.DocWrappedServiceImpl"&gt;
 &lt;classpath&gt;
 &lt;pathelement path="${tests.output.dir}/classes"/&gt;
 &lt;/classpath&gt;
 &lt;/wsprovide&gt;
&lt;/target&gt;
</programlisting>
</para>
<para>
Category:Tools (Category:Tools)
</para>
</section>

</section>
</article><article id="Wsrunclient">
<title>Wsrunclient</title>
<para>
wsrunclient is a command line tool that invokes a JBossWS JAX-WS Web Service client.It builds the correct classpath and endorsed libs for you. Feel free to usethe code for this script to make your own shell scripts. It is open sourceafter all.
</para>
<section id="Wsrunclient_Usage"><title>Usage</title>
<para>
<programlisting> wsrunclient [-classpath &lt;additional class path&gt;] &lt;java-main-class&gt; [arguments...]</programlisting>
</para>

</section>
<section id="Wsrunclient_Examples"><title>Examples</title>
<para>
Invoking a standalone JAX-WS client:<programlisting>wsrunclient echo.EchoClient</programlisting>
</para>
<para>
Invoking a standalone JAX-WS client that uses external jars:<programlisting>wsrunclient -classpath jar1.jar:jar2.jar echo.EchoClient</programlisting>
</para>
<para>
Category:Tools (Category:Tools)
</para>
</section>
</article>
</book>